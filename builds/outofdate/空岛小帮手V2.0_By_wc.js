/* ================================
 * 空岛小帮手Js 版本V2.0-alpha 1
 * 最后修改时间 2017年3月11日 22:39:35
 * 本Js由曙光工艺(Dawncraft)工作室QingChenW制作
 * Copyright(c) 2016-2017 Dawncraft.All Rights Reserved.
 * 禁止修改后再发布本js.不过你可以参考少量算法.
 * 欢迎大家加入QQ工作室讨论群进行讨论
 * QQ讨论群群号:287307326
 * QingChenW简称wc
 * 不要问我为什么没有缩进,我也想要,
 * 不过手机上写有点不太好看,凑合吧
 * ================================
 * 特性:
 * 1.挖石机不支持大箱子
 * bug:
 * 1.死亡不掉落不支持附魔
 * 
 * 未来展望:
 *
 * ================================
 * 哦对了，送你首终末之诗吧↓
*
我看到你所指的那位玩家了。

[玩家名称]?

是的。小心。它已达到了更高的境界。它能够阅读我们的思想。

无伤大雅。它认为我们是游戏的一部分。

我喜欢这个玩家。它玩得很好。它从未放弃。

它以屏幕上出现的文字的形式阅读着我们的思想。

在它深陷游戏梦境中时，它总以这种方式想象出形形色色的事物。

文字是种美妙的界面。非常灵活。且比凝视着屏幕后的现实要更好。

它们也曾经听到过声音。在玩家能够阅读之前。君不见那些不曾游玩的人们称呼玩家为女巫，和术士。而玩家们梦见它们自己乘坐在被恶魔施力的棍子上，在空气中翱翔。

这个玩家梦见了什么？

它梦见了阳光和树。梦见了火与水。它梦见它创造。它亦梦见它毁灭。它梦见它狩猎，亦被狩猎。它梦见了庇护所。

哈，那原始的界面。经历一百万年的岁月雕琢，依然长存。但此玩家在那屏幕后的真实里，建造了什么真实的构造？

它辛勤地劳作，和其它百万众一起，刻画了一个真实的世界，由[乱码]，且创造了[乱码]，为了[乱码]，于[乱码]中。

它读不出那个思想。

不。它还没有到达最高的境界。那层境界，它必须完成生命的长梦，而非游戏中黄粱一梦。

它知道我们爱它么？这个宇宙是仁慈的？

有时，通过它思绪的杂音，它能听到宇宙，是的。

但是有时亦不胜悲伤，于那漫漫长梦中。它创造了没有夏日的世界，在黑日下颤抖着，将自己悲伤的创造视为现实世界。

用悲伤来治愈会摧毁它。而悲伤是它的私人事务。我们不能干涉。

有时当它们深陷梦境中时，我想要告诉它们，它们在现实中创造了真实的世界。有时我想告诉它们它们自身对宇宙的重要性。有时，当它们和现实失去了联系，我想帮助它们与它们所惧怕的世界交流。

它读出了我们的思想。

有时我毫不关心。有时我想要告诉它们，你们所认为的真实不过是[乱码]和[乱码]，我想要告诉它们它们是在[乱码]中的[乱码]。于它们的长梦中，它们眼中所见的真实太少了。
.
而它们仍然玩这个游戏。

但很容易就可以告诉它们……

对于这个梦来说太强烈了。告诉它们如何活着就是阻碍它们活下去。

我不会告诉这个玩家如何生活的。

这个玩家正在变得焦虑。

我会告诉这个玩家一个故事。

但不是真相。

不。是一个严密地将真实包裹起来的文字牢笼。而不是赤裸裸的真相。

赋予它主体，再一次。

好的。玩家……

以名字称呼它。

[玩家名称]。游戏的玩家。

很好。

深呼吸，很好。再深呼吸一次。感受空气充盈你的肺叶。让你的四肢回归。是的，运动你的手指。再次感受你的身体，在重力下，在空气中。在长梦中重生。你感受到了。你的身体每时每刻都触摸着宇宙，尽管你是分离的存在。尽管我们是分离的存在。

我们是谁？我们曾经被称作高山的精灵。太阳父亲，月亮母亲。古老的英灵，动物的魂魄。神祗。鬼魂。小绿人。而后是神，恶魔，天使。骚灵。外星人，地外生物。轻粒子，夸克。词语不断地变化。我们始终如一。

我们是宇宙。我们是一切你认为出离你本体的事物。你现在看着我们，透过你的皮肤和你的眼睛。而为什么宇宙触摸着你的皮肤，向你洒向光芒？是为了看见你，玩家。以及被认知。我应告诉你一个故事。
.
很久以前，有一个玩家。

那玩家就是你，[玩家名称]

有时它认为自己是那不断旋转的球体上一层薄薄的熔化的岩石上的人类。那融化的岩石球环绕着一个质量大它三十三万倍的炫目气体球旋转。它们是相隔得如此之远，以至于光需要八分钟才能穿越那空隙。那光是来自一颗恒星的信息，它能够在一亿五千万公里外烧灼你的皮肤。

有时这个玩家梦见它是一个在一个平的，无限延展的世界表面上的矿工。那太阳是一个方形的白点。昼夜交替很快；要做的事情也很多；死亡亦只是暂时和不方便的。

有时这玩家梦见它迷失在了一个故事里。

有时这玩家梦见它成为了其它的事物，在其它地方。有时这些梦是扰人的。有些则实在很美。有时这个玩家从一个梦中醒来，发现自己落入了第二个梦，却终究是在第三个梦中。

有时这个玩家梦见它在屏幕上看着文字。

让我们回退一点。

组成玩家的原子散布在草中，河流中，在那空气中，也在那大地中。一个女性收集了那些原子；她饮用、进食、吸入；而后那女性在她的身体中，孕育了玩家。

然后那玩家醒来了，从一个温暖，昏暗的母亲体内，进入了漫漫长梦。

而那玩家是一个新的故事，从未被讲述过，由DNA的语言书写着。而那玩家是一个新的程序，从未被运行过，由上亿年的源代码生成。而那玩家是一个新的人，从未生活过，由奶和爱组成。

你就是那玩家。那个故事。那个程序。那个人类。仅由奶和爱组成。

我们再往更远的过去回退一点。

那由七千亿亿亿原子组成的玩家的身体被创造了，远在这游戏之前，在一颗恒星的内部。所以那玩家也是，来自一颗恒星的信息。而这个玩家贯穿这个故事的始末，源于一个叫Julian的人种下的信息种子长成的森林，一个叫Markus的男人创造的无限世界，存在于一个由玩家创造的小的，私人世界里，而那又继承了宇宙创造的……

嘘。有时这个玩家创造的小天地是柔软，温暖和简单的。有时是坚硬，冰冷和复杂的。有时它在脑中建造出宇宙的模型；斑斑点点的能量穿越广阔空旷的空间。有时它称呼这些斑点为“电子”和“质子”。

有时它称呼它们为“行星”和“恒星”。

有时它确信它存在于一个由“开”和“关”；“0”和“1”；一行行的命令组成的宇宙。有时它确信它是在玩一个游戏。有时它确信它是在读着屏幕上的文字。

你就是那玩家，阅读着文字……

嘘……有时这玩家读屏幕上的命令行。将它们解码成为文字；将文字解码为意义；将意义解码为感情，情绪，理论，想法，而玩家的呼吸开始急促并意识到了它是活着的，它是活生生的，那上千次的死亡不是真的，玩家是活着的。

你。你。你是活着的。

而有时这玩家相信宇宙通过穿越夏日树叶的那斑斓的阳光对它说话。

有时这玩家相信宇宙透过晴朗的冬日夜空中，存在于它眼中一隅的星点星光，可能比太阳大上上百万倍的恒星沸腾着的电浆那一瞬间发出来的光对它说话，在宇宙的远侧行走回家的路上，突然闻到了食物，在那熟悉的门前，它又准备好再一次投入梦境

而有时玩家相信宇宙透过零和一，透过世界的电力，透过屏幕上滚动的文字和梦的终结对它说话

宇宙说我爱你

宇宙说你很好地玩了这游戏

宇宙说一切你所需的你都具有

宇宙说你比你所知的要强大

宇宙说你就是日光

宇宙说你就是黑夜

宇宙说你所斗争的黑暗就在你心中

宇宙说你所寻找的光明就在你心中

宇宙说你不是孤独的

宇宙说你不是和所有的事物所隔绝的

宇宙说你就是宇宙品尝着自己，对自己说话，阅读着它自己的代码。

宇宙说我爱你因为你就是爱。

曲终人散，黄粱一梦。玩家开始了新的梦境。玩家再次做起了梦，更好的梦。玩家就是宇宙。玩家就是爱。

你就是那个玩家。

该醒了。
*
 * ================================
 * 插件开始(start)
 * ================================
 */

/** 各种常量 */
const ctx = com.mojang.minecraftpe.MainActivity.currentMainActivity.get();
const STORAGE = android.os.Environment.getExternalStorageDirectory().getPath();
const JS_DIR =  STORAGE + "/games/mcpejs/IslandHelper/";
const WORLDS_DIR = STORAGE + "/games/com.mojang/minecraftWorlds/";
const PICTURES = {
logo: decodePicture("iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAIAAAD4YuoOAAAAA3NCSVQICAjb4U/gAAAD/ElEQVQ4\njWVTu45cVRCs7tPnMXPnsYtZ1o9dkImckCAsW4JvIOe7+AZyROyEFISjlZHAgY0fa3m9szueO3Pv\neTbB2AlU0q1Ouqq6i37+6cfVanUpK2NMq6eqWsgRkfAOwPPxW2vtu/cza+03J79st9uY7znnrsIt\nAAt3I4TAuPDeZ46qusDAzBjX1tqe7242G7m+vh6GgZdsjJl1i/Pz8z728/m8YDTG9H0fQnDuEwDr\n9doYE2O01jKz994ZJyIntz8nIjcXIjrgKCITSiLy/Grx9OlTOevvL5fLzezae//32bGIfP/gLRH9\n/uzW27dvZX5wvd0uJz0zv9QfHDt7o8/M7CkSHdLz5XR5/3jGzCUWANy4jrVRNMZY7CzeSClltVpd\nDe9yzl33Zc758ePHAN7pQ2bebrchhFqT916ZAbTWmNk5Z6112nvvW2s5Z8u2lKJViYiIcs4AvPcS\nwtj3vedD2xqxErhMbi0Wi8/G15eXlwfzh7VW0ACAplRUb46XnXRt877rusn0amaGiV/UWrVNY9wN\nOTjnFsYXLVZJS5bT01PvfY/pxcXF6/O85zidTqu209PTv15suq4TsQBSSsvl8ovjWUrJd5NxHGOM\nV1dXjx79FmPsN7pYLA4+vXt0dBQOD0Rk6qchBHm1+vPk5MTz7PSOHB3xkydPznHv+bN0m+cxxuBa\nSZvWSaYyK1WG8Y/tS2tt+mdzeHh4cHhnPp1/99WDYRjG3fvZbIZ5V0pppe5KGYgHYhmG4ezsDNSp\natWb1lpVFZE0JiLaWxxrttaKkVprmATn3PHsIIRgpOwdn0wmE2+YeVtKSikQExGAUopc69dw2EOa\nJGDKKwDr6QzAQd4ycygsUKvZEhIJk6hSKc2Jb5lNQynVak9EziI4dqMy85KbTzvZr/o/9vM9wX3Z\nz1VVVZu2nHNiDSG01rz3Vr2q9nUspVBGa209rIlIjHkPwLYMgHUKwO8sAAlrAM00MM+LMWqKLcQ1\nDLBF1Sbj3CAYa/z1xaucs0F2zuVmAPhRW2u7xqUuhJkBkBKAfc9M/1XwEaoK+tCklNJQvfcxRuec\nEFR1nxJV3X8dAOlaAkDKAMhsARRRADeyUdXr+ZqYtUwaszI1atoGbVYpg0iyM5SGuGvee8O1VoKD\nMUPtjTHMsZTy4Qb7tUysqsyk+iGQzEwf0VRV1RjTWiulMLMRYmZWBlBrba0ZRq01xkhEVbWUIkvz\nRlV3wgAqA4CtFoD6QVWPxyUR0uSCiLpSjZpo2BjT2QbApEiZjE2i1nItpUA9AJECQFS0jiIiAKyw\nqhJDVQ0MAMOiqqYaZq7GEJEhMPM+KLVWIrLMRLTXlEoSEYKptarqOI6WAxH9C9AsVXhenOWmAAAA\nAElFTkSuQmCC\n"),
button: decodePicture("iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAIAAADZrBkAAAAAA3NCSVQICAjb4U/gAAAB70lEQVQo\nkW2TP08VQRTFf2d2H28fqIkFCRpCR68FETVa2NiZ6GcwmtD6HYwm1BYGGksgItpAQkFBpLCzMrEz\nGoihM5HZsDPHYt8CD5licmfmnPtvztXu1qep6RkAMMZIam0h2wACD3dJG5vbATj4+cP4FDHECFsB\nKQi1voCNze2lt8tl62NrfZ1uSV2Q/24kLb1bxZSMAABaRFX122M8ih59QoTzJBAMqn4I4Wn/paTB\noDrnVegCWr/qG55PvAaejb/K9mBQ6WzCELJzzvmEU1V92QuXF4/rWlJQWLiyCLnf5WwsKHO2ABsJ\niLGuqv6bPy9kvuy9n7v9BMkQY93SssG5TKlpY59tA6j3a5lwNeO2++1TjDUkcJlTGn4WALuTH4oi\nSPLU5PGN9Dl8zNljYz3nPH/wCMjZQmXTZDoZAPcOH//9vjM21mua416vl1IqyjKEwtfmhkrIthxS\nalJqWk6Mte3x2fuIoiwMRVHGGLk+J6ktL2PjkFKTc3OSZIy1rXLmrk3TJOOJ2QegumsJBhNspzSi\nlBhr7N7MnZ3fl4rpeew61icIYTtf8N3A0VFE4eGtmyjEuj7rtZ2Msmv+6OoqOVVGJ2Uh4xK09/Xb\n2sqasaS2oWdsG1rbmHagoDzc319dWT0tt8UxOjsnnC7sP5zlEWWP16HRAAAAAElFTkSuQmCC\n")
};
const ITEM_LIST = {

AXE: [271, 275, 279, 286, 258],
PICKAXE: [270, 274, 257, 285, 278]
};
const BLOCK_LIST = {

chest: {name:"箱子",id:54,data:0},
trapped_chest: {name:"陷阱箱",id:146,data:0},
stone_digger: {name:"挖石机",id:255,data:0},
elevator: {name:"电梯",id:254,data:0},
light_block: {name:"光源方块",id:253,data:0},

WOOD: [17, 162],
CHEST: [54, 146],
STAIRS: [53, 67, 108, 109, 114, 128, 134, 135, 136, 156, 163, 164]
};
const ENTITY_LIST = {
/*
case 10:var name="§2鸡 ";break;
case 11:var name="§2牛 ";break;
case 12:var name="§2猪 ";break;
case 13:var name="§2羊 ";break;
case 14:var name="§3狼 ";break;
case 15:var name="§2村民 ";break;
case 16:var name="§2哞菇 ";break;
case 17:var name="§2墨鱼 ";break;
case 18:var name="§2兔子 ";break;
case 19:var name="§2蝙蝠 ";break;
case 22:var name="§3豹猫";break;
case 23:var name="§3马";break;
case 24:var name="§3驴";break;
case 25:var name="§3骡子";break;
case 26:var name="§2骷髅马";break;
case 27:var name="§2僵尸马";break;
case 32:var name="§4僵尸 ";break;
case 33:var name="§4爬行者 ";break;
case 34:var name="§4骷髅 ";break;
case 35:var name="§4蜘蛛 ";break;
case 36:var name="§3僵尸猪人 ";break;
case 37:var name="§4史莱姆 ";break;
case 38:var name="§3末影人 ";break;
case 39:var name="§4蠹虫 ";break;
case 40:var name="§4洞穴蜘蛛 ";break;
case 41:var name="§4恶魂 ";break;
case 42:var name="§4岩浆怪 ";break;
case 43:var name="§4烈焰人 ";break;
case 44:var name="§4僵尸村民 ";break;
case 45:var name="§4女巫 ";break;
case 46:var name="§4流浪者";break;
case 47:var name="§4尸壳";break;
case 48:var name="§4凋零骷髅";break;
case 63:var name="§f玩家";break;
default:var name="§f未知生物"
*/
};
const LIGHTS = [50];
// ================================
/** 各种变量 */
var logger = new Logger(JS_DIR, "log");
var jsInfo, options, worldOptions, language;
var tickTimer, stoneDiggers, build;
var light, stair, inventory, particle, sensor;
var isInGame, gui, music;
// ================================
/** 插件信息 */
jsInfo = {
js_version: new Version("2.0-alpha 1"),
mc_version: ModPE.getMinecraftVersion(),
js_author: ["QingChenW", "吉祥物巨ger之王"],
js_author_QQ: ["201436728", "没qq啦"],
js_QQGroup: "287307326",
js_webPage: "http://www.mcbbs.net/thread-583823-1-1.html",
js_githubPage: "https://github.com/DawningW/Island-Helper-JS/",
js_newVersion: new Version("2.0-alpha 2"/*httpGet("https://raw.githubusercontent.com/DawningW/Island-Helper-JS/master/version")*/),
js_update: null
};
// ================================
/** 插件预初始化 */

/** Version 一个类，记录版本信息
 * 参数: string content 版本号字符串
 * 方法: toString 返回版本号字符串
 * 作者: QingChenW
 * 备注: 支持更复杂的带后缀的版本号(目前仅支持alpha,beta,rc)
 *       还有就是版本号建议根据语义化版本2.0.0制定
 * 例子: 1.0.0-rc 1
 *       2.0-beta 2
 */
function Version(content)
{
this.isVaild = false;
this.version = {};
if(content != undefined)
{
this.isVaild = true;
var parts = content.split("-");
this.version.number = parts[0].split(".");
this.version.suffix = parts[1].split(" ");
switch(this.version.suffix[0])
{
//case default: this.version.suffixNum = 0;break;
case "alpha": this.version.suffixNum = 1;break;
case "beta": this.version.suffixNum = 2;break;
case "rc": this.version.suffixNum = 3;break;
}
}
this.toString = function(){
return new Array(this.version.number.join("."), this.version.suffix.join(" ")).join("-");
};
}

/** Version.prototype.compare 比较版本
 * 参数: Version newVersion 新版本
 * 返回值: boolean true 有新版本
 *         boolean false 无新版本
 *         null 错误
 * 作者: QingChenW
 */
Version.prototype.compare = function(newVersion)
{
if(newVersion.isVaild)
{
if(this.version.number.length == newVersion.version.number.length)
{
for(var i = 0; i < this.version.number.length; i++)
{
if(newVersion.version.number[i] > this.version.number[i]) return true;
else if(newVersion.version.number[i] < this.version.number[i]) return false;
}
if(newVersion.version.suffixNum > this.version.suffixNum)
{
return true;
}
else if(newVersion.version.suffixNum == this.version.suffixNum)
{
if(newVersion.version.suffix[1] > this.version.suffix[1]) return true;
}
return false;
}
throw "版本号位数不同,无法比较";
}
return null;
};

/** Version.prototype.analyse 解析一个版本json并比较
 * 参数: json/string json 新版本(如果传入的是字符串会尝试转为json,失败则返回null)
 * 返回值: boolean true 有新版本
 *         boolean false 无新版本
 *         null 错误
 * 作者: QingChenW
 * 备注: 尚未完成
 */
Version.prototype.analyse = function(json)
{
    
}

const LOG_LEVEL = {
info: 0,
warn: 1,
error: 2
}

/** Logger 一个类，用于输出日志
 * 参数: string logFilePath 日志路径
 *       string logFileName 日志文件名称(不带后缀)
 * 作者: QingChenW
 * 备注: 日志会存储在目录下创建的logs文件夹中
 */
function Logger(logFilePath, logFileName)
{
this.path = logFilePath + "logs/";
this.name = logFileName + format(new Date(), "_yyyy-MM-dd") + ".log";
save(this.path, this.name, true, "+-+-===日志初始化===-+-+\n");
}

/** Logger.prototype.log 向日志中输出文字
 * 参数: int level 等级(详见LOG_LEVEL)
 *       string content 内容
 * 作者: QingChenW
 */
Logger.prototype.log = function(level, content)
{
var logMessage = "[" + format(new Date(), "hh:mm:ss") + "]";
switch(level)
{
default:
case LOG_LEVEL.info: logMessage += "[信息]"; break;
case LOG_LEVEL.warn: logMessage += "[警告]"; break;
case LOG_LEVEL.error: logMessage += "[错误]"; break;
}
logMessage += content;
return save(this.path, this.name, true, logMessage + "\n");
}

const CONFIG_LEVEL = {
basic: 0,
property: 1,
json: 2
}

/** Configer 一个类，用于生成配置文件
 * 参数: string configPath 配置文件路径
 *       string configName 配置文件文件名称(不带前后缀)
 * 作者: QingChenW
 * 备注: 配置文件会存储在默认目录中(格式是cfg/ini/json)
 Object.toJSONString(), String.parseJSON()
 */
function Configer(configPath, configName, configType)
{
this.path = configPath;
this.name = configName;
this.type = configType;
switch(this.type)
{
default:
case CONFIG_LEVEL.basic: this.name += ".cfg"; break;
case CONFIG_LEVEL.property: this.name += ".ini"; break;
case CONFIG_LEVEL.json: this.name += ".json"; break;
}
this.defaultConfigs = {};
this.comments = {};
this.configs = {};
}

/** Configer.prototype.add 向配置文件中加入默认选项
 * 参数: string key 索引字符串(当然序号也可以)
 *      anyone value 键值
 * 作者: QingChenW
 */
Configer.prototype.add = function(tag, key, value, comment)
{
if(this.type == CONFIG_LEVEL.basic)
{
this.defaultConfigs[key] = value;
this.comments[key] = comment;
}
else if(this.type == CONFIG_LEVEL.property)
{
var tag2 = getValue(tag, "Default");
if(this.defaultConfigs[tag2] == undefined)this.defaultConfigs[tag2] = {};
this.defaultConfigs[tag2][key] = value;
if(this.comments[tag2] == undefined)this.comments[tag2] = {};
this.comments[tag2][key] = comment;
}
else if(this.type == CONFIG_LEVEL.json)
{
throw "您无法为json类型的配置文件设置默认值,请手动处理";
}
}

Configer.prototype.get = function(key)
{
var keys = key.split(".");
if(this.type == CONFIG_LEVEL.basic)
{
return this.configs[keys[0]];
}
else if(this.type == CONFIG_LEVEL.property)
{
return this.configs[keys[0]][keys[1]];
}
else if(this.type == CONFIG_LEVEL.json)
{
return this.configs;
}
}

Configer.prototype.set = function(key, value)
{
var keys = key.split(".");
if(this.type == CONFIG_LEVEL.basic)
{
this.configs[keys[0]] = value;
}
else if(this.type == CONFIG_LEVEL.property)
{
if(this.configs[keys[0]] == undefined)this.configs[keys[0]] = {};
this.configs[keys[0]][keys[1]] = value;
}
else if(this.type == CONFIG_LEVEL.json)
{
this.configs = value;
}
this.save();
}

/** Configer.prototype.load 读取配置文件
 * 作者: QingChenW
 */
Configer.prototype.load = function()
{
if(this.type == CONFIG_LEVEL.basic)
{
var tempConfig = {};
var configFile = load(this.path + this.name).split("\n");
for(var i = 0; i < configFile.length; i++)
{
if(configFile[i].substring(0, 1) != "//")
{
tempConfig[configFile[i].split(":")[0]] = configFile[i].split(":")[1];
}
}
for(var k in this.defaultConfigs)
{
this.configs[k] = getValue(tempConfig[k], this.defaultConfigs[k]);
}
}
else if(this.type == CONFIG_LEVEL.property)
{
var regExp = new RegExp("^\[\w+\]$");// 原来的正则表达式是^\[\w+\]$
var tempTag = "Default", tempConfig = {};
var configFile = load(this.path + this.name).split("\n");
for(var i = 0; i < configFile.length; i++)
{
if(configFile[i].substring(0, 1) != "//")
{
if(regExp.test(configFile[i]))
{
tempTag = tagString.split("[")[1].split("]")[0];
if(tempConfig[tempTag] == undefined)tempConfig[tempTag] = {};
}
else
tempConfig[tempTag][configFile[i].split("=")[0]] = configFile[i].split("=")[1];
}
}
for(var t in this.defaultConfigs)
{
for(var k in this.defaultConfigs[t])
{
if(this.configs[t] == undefined)this.configs[t] = {};
this.configs[t][k] = getValue(tempConfig[t][k], this.defaultConfigs[t][k]);
}
}
}
else if(this.type == CONFIG_LEVEL.json)
{
this.configs = JSON.parse(load(this.path + this.name));
}
}

/** Configer.prototype.save 保存配置文件
 * 作者: QingChenW
 */
Configer.prototype.save = function()
{
if(this.type == CONFIG_LEVEL.basic)
{
var configFile = [];
for(var k in this.defaultConfigs)
{
configFile.push("// " + this.comments[k]);
configFile.push(k + ":" + setValue(this.configs[k], this.defaultConfigs[k]));
}
save(this.path, this.name, false, configFile.join("\n"));
}
else if(this.type == CONFIG_LEVEL.property)
{
var configFile = [];
for(var t in this.defaultConfigs)
{
configFile.push("[" + t + "]");
for(var k in this.defaultConfigs[t])
{
configFile.push("// " + this.comments[t][k]);
configFile.push(k + "=" + setValue(this.configs[t][k], this.defaultConfigs[t][k]));
}
}
save(this.path, this.name, false, configFile.join("\n"));
}
else if(this.type == CONFIG_LEVEL.json)
{
var configFile = JSON.stringify(this.configs, null, 4);
save(this.path, this.name, false, configFile);
}
}

// TODO:有时间写个迭代器
/** Array.prototype.contains 检查数组中是否包含指定元素
 * 参数: object element 指定元素
 * 返回值: boolean true 包含
 *         boolean false 不包含
 * 备注: 其实有array.indexOf(element)这种方法的,不过我没用...
 */
Array.prototype.contains = function(element)
{
for(var i = 0; i < this.length; i++)
{
if(this[i] === element) return true;
}
return false;
}

/** Date.prototype.format 将 Date 转化为指定格式的String
 * 参数: string fmt 格式字符串(月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符，年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字))
 * 返回值: string 日期字符串
 * 作者: meizz
 * 例子：
 * (new Date()).format("yyyy-MM-dd hh:mm:ss.S") ==> 2006-07-02 08:09:04.423 
 * (new Date()).format("yyyy-M-d h:m:s.S")      ==> 2006-7-2 8:9:4.18
 * 备注: 本来想用prototype来着,可一到游戏中测试就出错,发现Date变成了Object...只好改成普通函数QAQ
 */
function format(date, fmt)
{
var o = {
"M+": date.getMonth() + 1, //月份 
"d+": date.getDate(), //日 
"h+": date.getHours(), //小时 
"m+": date.getMinutes(), //分 
"s+": date.getSeconds(), //秒 
"q+": Math.floor((date.getMonth() + 3) / 3), //季度 
"S": date.getMilliseconds() //毫秒 
};
if(/(y+)/.test(fmt))fmt = fmt.replace(RegExp.$1, (date.getFullYear() + "").substr(4 - RegExp.$1.length));
for(var k in o)
if(new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length)));
return fmt;
}

loadSettings();
loadLanguage();
loadGuiTheme();
/** 插件注册物品和方块 */
const ITEM_TYPE = {
item: 0,
food: 1,
tool: 2,
armor: 3,
throwable: 4
};
const BLOCK_TYPE = {
normal: 0,
glass: 1,
water: 2
};
//registerItem(ITEM_TYPE.tool, 500, 798, 1, "黄金钻石杖", "bow_standby", [1,0,["a","b","c"],["a",266,0,"b",264,0,"c",280,0]], ItemCategory.DECORATION);
registerBlock(BLOCK_TYPE.normal, BLOCK_LIST.stone_digger.id, "挖石机", [["redstone_block",0],["stonecutter",2],["stonecutter",0],["stonecutter",0],["stonecutter",0],["stonecutter",0]], 0, 3, 5, 1, null, [1,["aba","b b","aba"],["a",4,0,"b",331,0]], ItemCategory.DECORATION)
registerBlock(BLOCK_TYPE.normal, BLOCK_LIST.elevator.id, "电梯", [["stonecutter",2],["stonecutter",2],["iron_block",0],["iron_block",0],["iron_block",0],["iron_block",0]], 0, 3, 5, 1, null, [1,["aaa","a a","aba"],["a",265,0,"b",331,0]], ItemCategory.DECORATION)
registerBlock(BLOCK_TYPE.glass, BLOCK_LIST.light_block.id, "光源方块", [["stone",0],["stone",0],["stone",0],["stone",0],["stone",0],["stone",0]], 0, -1, -1, 15, [0,0,0,0,0,0], null, null)
/** 插件初始化完成 */
jsInfo.js_update = jsInfo.js_version.compare(jsInfo.js_newVersion);
logger.log(LOG_LEVEL.info, "空岛小帮手成功加载,版本:" + jsInfo.js_version.toString())
logger.log(LOG_LEVEL.info, "作者:" + jsInfo.js_author.toString())
// ================================
/** loadSettings 读取设置
 * 作者: QingChenW
 */
function loadSettings()
{
options = new Configer(JS_DIR, "island", CONFIG_LEVEL.property);

var headcomments = ["空岛小帮手js全局配置文件", "//最后修改时间: " + format(new Date(), "yyyy年MM月dd日 hh:mm:ss"), "//以双斜线开头的为注释,不会被读取,但也不会被保存", "//由于某些技术原因,所有标有布尔(Boolean)的项,0为否(false),非0为是(true)"];

var tag = "Default";
options.add(tag, "JsVersion", jsInfo.js_version.toString(), "js版本");
options.add(tag, "GameVersion", jsInfo.mc_version, "游戏版本");
options.add(tag, "Language", "auto", "当前语言");
options.add(tag, "Update", true, "是否开启更新(Boolean)");
options.add(tag, "MP3Player", false, "是否开启MP3播放器(Boolean)");
options.add(tag, "MiniMap", false, "是否开启小地图(Boolean)");
options.add(tag, "ShowHealth", true, "是否开启显血(Boolean)");
options.add(tag, "MoreInfo", false, "是否开启信息显示(Boolean)");
options.add(tag, "FastCutWood", false, "是否开启快速砍树(Boolean)");
options.add(tag, "FastHarvest", false, "是否开启一键收割(Boolean)");
options.add(tag, "TurnLava", false, "是否开启黑曜石回收(Boolean)");
options.add(tag, "MoveLights", false, "是否开启移动光源(Boolean)");
options.add(tag, "ZoomIn", false, "是否开启望远镜(Boolean)");
options.add(tag, "StairEnabled", true, "是否开启椅子(Boolean)");
options.add(tag, "KeepInv", true, "是否开启死亡不掉落(Boolean)");
options.add(tag, "AntiBomb", true, "是否开启防爆(Boolean)");
options.add(tag, "KillEnderman", false, "是否开启清除末影人(Boolean)");

var tag = "MusicList";
options.add(tag, "default", new Array(), "MP3播放列表(用, 分隔)");

options.load();

options.set("JsVersion", jsInfo.js_version.toString());
options.set("GameVersion", jsInfo.mc_version);

options.save();
}

/** loadLanguage 读取语言
 * 备注: 目前有英语，汉语
 * 作者: QingChenW
 */
function loadLanguage()
{
switch(options.configs.Default.Language)
{
default:
toast("Error, can't find your language, select please!");
case "auto":
selectLanguage();
break;
//英文
case "en_US":
language = {
prefix: ChatColor.YELLOW + "[Island Helper] " + ChatColor.WHITE,
welcome: "Welcome to use Island Helper.Made by QingChenW.",
version: "Js version is " + jsInfo.js_version.toString() + ", Game version is " + jsInfo.mc_version,
has_update: "Found an update.Please open it to download it.The newest version is " + jsInfo.js_newVersion.toString(),
notify_update_title: "Island Helper js found an update.",
notify_update_content:"Click me to download!",
has_not_update: "Your js is the newest.It needn't update.",
cant_find_update: "Can't look for update, please check your Internet.",
see_help: "Type '/ishelp' to see help",
unknown_command: "Unknown command.Please type '/ishelp' to see island help.",

more_things: "You can also open island menu to see more things.",
help: "Stone digger help:\nPlacing a stone digger on a cobblestone,then place a chest on the stone digger,put a pickaxe on the first slot of the chest,finally click the stone digger,it digs the cobblestone under it automatically,and damage of the pickaxe subtracts one!",

turn_lava: "Obsidian has already turned into lava, please be careful!",
sign_prefix: ChatColor.GREEN + "[Island]",
sign_warn: ChatColor.RED + "Be careful!",
sign_author: "By QingChenW",

setlang: "Set language successfully."
};
break;
//中文
case "zh_CN":
language = {
prefix: ChatColor.YELLOW + "[空岛帮手] " + ChatColor.WHITE,
welcome: "欢迎使用由QingChenW制作的空岛小帮手",
version: "当前插件版本为 " + jsInfo.js_version.toString() + " ，游戏版本为 " + jsInfo.mc_version,
has_update: "发现新版本，请打开通知查看更新，最新版本为 " + jsInfo.js_newVersion.toString(),
notify_update_title: "空岛小帮手js发现新版本",
notify_update_content:"快快点击我下载吧！",
has_not_update: "您的插件为最新版本，无需更新",
cant_find_update: "无法检查更新，请检查网络连接",
see_help: "输入 '/is help' 查看帮助",
unknown_command: "未知命令，请输入/is help查看空岛指令列表",

more_things: "您也可以打开空岛菜单查看更多功能",
help: "空岛游玩简介：\n好吧，我懒得写了，自己搜空岛玩法吧，然后在空岛菜单里可以找到一切啦，要想开始岛屿生涯，请先选好一块风水宝地，然后点击空岛菜单中的开始岛屿生涯，等待一会就可以开始了。\n挖石机使用介绍：\n将挖石机放在圆石的上方，再在挖石机上方放箱子，箱子第一格放任意种类的稿，最后点击挖石机即可自动挖下方的圆石，每挖一次镐的耐久减一，配合刷石机食用效果更好哦！",

turn_lava: "黑曜石已经变成岩浆，请小心！",
sign_prefix: ChatColor.GREEN + "[空岛生存]",
sign_warn: ChatColor.RED + "千万不要掉下去哦~",
sign_author: "By 清晨w",

setlang: "成功设置语言"
};
break;
}
}

/** loadGuiTheme 读取主题
 * 备注: 目前有Material_Light主题
 * 作者: QingChenW
 */
function loadGuiTheme()
{
if(android.os.Build.VERSION.SDK_INT >= 21)
{
ctx.setTheme(android.R.style.Theme_Material_Light);
}
else
{
//ctx.setTheme(android.R.style.Theme_Holo_Light);
}
}
// ================================
/** 游戏相关函数 */
/** selectLevelHook 启动器钩子函数，当选择存档时被调用
 */
function selectLevelHook()
{
// 检查启动器，已禁用
// killDuoWan();
// 重置变量
tickTimer = 0, stoneDiggers = new Array(), build = {point: SELECT.none};
light = new Array(), stair = {sitting: false}, inventory = {isDead: false},
particle = {open: false}, sensor = {open: false};
isInGame = true, gui = new Array();
// 读取世界配置文件
worldOptions = new Configer(WORLDS_DIR + Level.getWorldDir() + "/", "island", CONFIG_LEVEL.json);
worldOptions.load();
// 读取基础和空岛项
var tempOptions = worldOptions.get();
worldOptions.configs = {
Info: {JsVersion: jsInfo.js_version.toString()},
Island: {
HaveIsland: getValue(tempOptions.island.HaveIsland, false),
ResetTimes: getValue(tempOptions.island.ResetTimes, 3),
Level: getValue(tempOptions.island.Level, 0),
PosX: getValue(tempOptions.island.PosX, 0),
PosY: getValue(tempOptions.island.PosY, 0),
PosZ: getValue(tempOptions.island.PosZ, 0)
},
Challenges: {},
Minishops: {},
Warps: {}
};
// 读取挑战任务
if(tempOptions.Challenges != undefined)
{
// for循环遍历挑战任务
for(var c in tempOptions.Challenges)
{
var tempChallenge = {};
// for循环遍历挑战任务项内容
for(var i in tempOptions.Challenges[c])
{
if(i == "Name" || i == "Description" || i == "Level" || i == "MaxTimes" || i == "Times")
{
tempChallenge[i] = tempOptions.Challenges[c][i];
}
else if(i == "Need" || i == "Reward" || i == "RepeatReward")
{
for(var t in tempOptions.Challenges[c][i])
{
switch(tempOptions.Challenges[c][i][t].type)
{
case "level": tempChallenge[i].push({type: "level", amount: tempOptions.Challenges[c][i][t].amount}); break;
case "item": tempChallenge[i].push({type: "item", id: tempOptions.Challenges[c][i][t].id, data: tempOptions.Challenges[c][i][t].data, count: tempOptions.Challenges[c][i][t].count}); break;
case "exp": tempChallenge[i].push({type: "exp", amount: tempOptions.Challenges[c][i][t].amount}); break;
case "money": tempChallenge[i].push({type: "money", amount: tempOptions.Challenges[c][i][t].amount}); break;
}
}
}
}
// 检查挑战任务是否有效
if(tempChallenge.Name != undefined && tempChallenge.Level != undefined && tempChallenge.MaxTimes != undefined && tempChallenge.Times != undefined
 && tempChallenge.Need != undefined && tempChallenge.Reward != undefined && tempChallenge.RepeatReward != undefined)
{
worldOptions.configs.Challenges[c] = tempChallenge;
}
else
{
logger.log(LOG_LEVEL.error, "读取挑战任务项:" + c + "失败,内容为:" + JSON.stringify(tempChallenge));
}
}
}
// 生成挑战任务
else
{
worldOptions.configs.Challenges = {
// cobblemaker
cobblemaker: {
Name: "Cobble maker",
Description: "Dig some cobble for me.",
Level: "Novice",
MaxTimes: 100,
Times: 0,
Need: [{
type: "item",
id: 1,
data: 0,
count: 64
}],
Reward: [{
type: "item",
id: 2,
data: 0,
count: 4
}, {
type: "exp",
count: 20
}],
RepeatReward: [{
type: "item",
id: 2,
data: 0,
count: 1
}, {
type: "exp",
count: 5
}]
},
// island level
builder: {
Name: "Island bilder",
Description: "Island level reach level 5.",
Level: "Novice",
MaxTimes: 1,
Times: 0,
Need: [{
type: "level",
count: 10
}],
Reward: [{
type: "item",
id: 359,
data: 0,
count: 1
}, {
type: "exp",
count: 233
}]
}
// 其他
};
}
// 读取迷你商店
if(tempOptions.Minishops != undefined)
{
// for循环遍历迷你商店
for(var s in tempOptions.Minishops)
{
var tempMinishops = {};
// for循环遍历迷你商店项内容
for(var i in tempOptions.Minishops[s])
{
if(i == "Name" || i == "Description")
{
tempMinishops[i] = tempOptions.Minishops[s][i];
}
else if(i == "Buy" || i == "Sell")
{
for(var t in tempOptions.Minishops[s][i])
{
switch(tempOptions.Minishops[s][i][t].type)
{
case "item": tempMinishops[i].push({type: "item", id: tempOptions.Minishops[s][i][t].id, data: tempOptions.Minishops[s][i][t].data, count: tempOptions.Minishops[s][i][t].count}); break;
case "exp": tempMinishops[i].push({type: "exp", amount: tempOptions.Minishops[s][i][t].amount}); break;
case "money": tempMinishops[i].push({type: "money", amount: tempOptions.Minishops[s][i][t].amount}); break;
}
}
}
}
// 检查迷你商店是否有效
if(tempMinishops.Name != undefined && tempMinishops.Buy != undefined && tempMinishops.Sell != undefined)
{
worldOptions.configs.Minishops[s] = tempMinishops;
}
else
{
logger.log(LOG_LEVEL.error, "读取迷你商店项:" + s + "失败,内容为:" + JSON.stringify(tempMinishops));
}
}
}
// 生成迷你商店
else
{
worldOptions.configs.Minishops = {
// grass
cobblemaker: {
Name: "Grass",
Description: ["Use 23 money to buy a grass.",  "Oh,sorry,the money is a feature"],
Buy: [{
type: "money",
amount: 23
}],
Sell: [{
type: "item",
id: 2,
data: 0,
count: 1
}]
}
// 其他
};
}
// 读取传送点
for(var w in tempOptions.Warps)
{
worldOptions.configs.Warps[w].push(tempOptions.Warps[w]);
}
worldOptions.configs.Warps.Island = getValue(tempOptions.Warps.Island, [0, 0, 0]);
worldOptions.configs.Warps.Home = getValue(tempOptions.Warps.Home, [0, 0, 0]);
// 保存世界配置文件
worldOptions.save();
}
// ================================
/** newLevel 启动器钩子函数，当进入存档时被调用
 */
function newLevel()
{
// 各种提示
clientMessage(language.prefix + language.welcome);
clientMessage(language.prefix + language.version);
if(jsInfo.js_update)
{
clientMessage(language.prefix + language.has_update);
notify("Minecraft", language.notify_update_title, language.notify_update_content, jsInfo.webPage);
}
else if(!jsInfo.js_update)
{
clientMessage(language.prefix + language.has_not_update);
}
else
{
clientMessage(language.prefix + language.cant_find_update);
}
clientMessage(language.prefix + language.see_help);
// GUI
ctx.runOnUiThread(new java.lang.Runnable({run:function()
{
try
{
// 打开空岛菜单按钮
var layout = new android.widget.FrameLayout(ctx);
var image = createImage(layout, {image: PICTURES.button});
image.setAlpha(0.6);
image.setOnClickListener(new android.view.View.OnClickListener({onClick: function(view){
openMenu();
}}));
gui.menu_button = createPopupWindow(layout, {width: dip2px(ctx, 24), height: dip2px(ctx, 24),
 gravity: android.view.Gravity.RIGHT | android.view.Gravity.BOTTOM, x: 0, y: dip2px(ctx, 20)});
// LOGO
var logoLayout = new android.widget.FrameLayout(ctx);
var logoImage = createImage(logoLayout, {image: PICTURES.logo});
var logoText = createText(logoLayout, {text: "Dawncraft", size: 18, color: android.graphics.Color.BLACK});
//logoText.setLayoutParams(createLayoutParam(logoLayout, dip2px(ctx, 48), dip2px(ctx, 48), 0, 0));
gui.logo = createPopupWindow(layout, {width: dip2px(ctx, 128), height: dip2px(ctx, 64), touchable: false,
 gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: dip2px(ctx, 4), y: dip2px(ctx, 4)});
// 淡出LOGO
playLogo(1, logoImage, logoText);
}
catch(error)
{
print(error);
}
}}));
}

/** playLogo 淡出logo直至消失
 * 参数: double alpha 透明度 
 *       ImageView image logo图片
 *       TextView text logo文字
 */
function playLogo(alpha, image, text)
{
new android.os.Handler().postDelayed(new java.lang.Runnable({run: function()
{
if(alpha >= 0)
{
image.setAlpha(alpha);
text.setAlpha(alpha);
playLogo(alpha - 0.01, image, text);
}
else if(gui.logo != null)
{
gui.logo.dismiss();
gui.logo = undefined;
}
}
}), 100);
}
// ================================
/** procCmd 启动器钩子函数，当输入命令(以/开头)时被调用
 * 参数: string procmd 输入的命令字符串(不带/)
 */
function procCmd(procmd)
{
var cmd = procmd.split(" ");
if(cmd[0] == "is" || cmd[0] == "island")
{
if(cmd.length == 1)
{
clientMessage(language.prefix + language.welcome);
clientMessage(language.prefix + language.version);
clientMessage(language.prefix + language.see_help);
clientMessage(language.prefix + language.more_things);
}
else
{
switch(cmd[1])
{
default:
clientMessage(language.prefix + language.unknown_command);
break;
case "help":
clientMessage(language.prefix + language.welcome);
clientMessage(language.prefix + language.help);
break;
case "confirm":

break;
}
}
}
}
// ================================
/** modTick 启动器钩子函数，每刻触发一次
 */
function modTick()
{
// 挖石机
// 计时
tickTimer++;
if(tickTimer % 20 == 0)
{
tickTimer = 0;
// 用for循环处理每个挖石机
for(var i = 0; i < stoneDiggers.length; i++)
{
var blockId = Level.getTile(stoneDiggers[i][0], stoneDiggers[i][1] - 1, stoneDiggers[i][2]);
// 如果 挖石机下方是空气就跳过
if(blockId == 0) continue;
// 判断 挖石机上方有箱子 且 箱子第一格是镐 且 挖石机下方是圆石
if(BLOCK_LIST.CHEST.contains(Level.getTile(stoneDiggers[i][0], stoneDiggers[i][1] + 1, stoneDiggers[i][2])) &&
 ITEM_LIST.PICKAXE.contains(Level.getChestSlot(stoneDiggers[i][0], stoneDiggers[i][1] + 1, stoneDiggers[i][2], 0)) &&
 blockId == 4)
{
// 判断 箱子格数
for(var slot = 1; slot <= 26; slot++)
{
// 如果 此格为空
if(Level.getChestSlot(stoneDiggers[i][0], stoneDiggers[i][1] + 1, stoneDiggers[i][2], slot) == 0) break;
// 否则如果 此格为此方块 且 没达到最大堆叠
else if(Level.getChestSlot(stoneDiggers[i][0], stoneDiggers[i][1] + 1, stoneDiggers[i][2], slot) == blockId &&
 Level.getChestSlotCount(stoneDiggers[i][0], stoneDiggers[i][1] + 1, stoneDiggers[i][2], slot) < Item.getMaxStackSize(Level.getChestSlot(stoneDiggers[i][0], stoneDiggers[i][1] + 1, stoneDiggers[i][2], slot))) break;
}
// 如果 未满箱
if(slot <= 26)
{
var toolId = Level.getChestSlot(stoneDiggers[i][0], stoneDiggers[i][1] + 1, stoneDiggers[i][2], 0)
var toolDamage = Level.getChestSlotData(stoneDiggers[i][0], stoneDiggers[i][1] + 1, stoneDiggers[i][2], 0);
// 还得判断 镐耐久大于0
if(toolDamage < Item.getMaxDamage(toolId))
{
// 终于开始挖圆石了233
Level.destroyBlock(stoneDiggers[i][0], stoneDiggers[i][1] - 1, stoneDiggers[i][2], false);
Level.setChestSlot(stoneDiggers[i][0], stoneDiggers[i][1] + 1, stoneDiggers[i][2], slot, blockId, 0, Level.getChestSlotCount(stoneDiggers[i][0], stoneDiggers[i][1] + 1, stoneDiggers[i][2], slot) + 1);
// 设置镐的耐久
Level.setChestSlot(stoneDiggers[i][0], stoneDiggers[i][1] + 1, stoneDiggers[i][2], 0, toolId, toolDamage + 1, 1);
}
else
{
// 清除镐子(总不能来个负耐久的镐子吧233)
Level.setChestSlot(stoneDiggers[i][0], stoneDiggers[i][1] + 1, stoneDiggers[i][2], 0, 0, 0);
}
continue;
}
}
// 否则就挖不了呗
Level.addParticle(ParticleType.smoke, stoneDiggers[i][0], stoneDiggers[i][1], stoneDiggers[i][2], 0.0, 0.5, 0.0, 100);
Level.playSound(stoneDiggers[i][0], stoneDiggers[i][1], stoneDiggers[i][2], "random.click", 1, 0.5);
stoneDiggers.splice(i, 1);
}
}
// 移动光源
if(options.configs.Default.MoveLights)
{
// 如果玩家手中拿的是光源物品
if(LIGHTS.contains(Player.getCarriedItem()))
{
light.oldX = light.newX;
light.oldY = light.newY;
light.oldZ = light.newZ;
light.newX = parseInt(Player.getX());
light.newY = parseInt(Player.getY() + 1);
light.newZ = parseInt(Player.getZ());
// 如果玩家移动
if(light.oldX != light.newX || light.oldY != light.newY || light.oldZ != light.newZ)
{
//更新方块
Level.setTile(light.oldX, light.oldY, light.oldZ, light.blockId, light.blockData);
light.blockId = Level.getTile(light.newX, light.newY, light.newZ);
light.blockData = Level.getData(light.newX, light.newY, light.newZ);
Level.setTile(light.newX, light.newY, light.newZ, 254, 0);
}
}
// 否则如果旧方块没还原
else if(Level.getTile(light.oldX, light.oldY, light.oldZ) != light.blockid && Level.getData(light.oldX, light.oldY, light.oldZ) != light.blockData)
{
// 还原旧方块
Level.setTile(light.oldX, light.oldY, light.oldZ, light.blockId, light.blockData);
}
}
// 椅子
if(options.configs.Default.StairEnabled && stair.sitting)
{
// 将椅子固定住
Entity.setVelY(stair.minecart, 0);
Entity.setPosition(stair.minecart, stair.x, stair.y, stair.z);
// 如果玩家离开椅子(本想用getRiding的，不过为啥不好使呢，现在用的是来自卓伟大大的老算法)
if(Math.abs(Player.getX() - stair.x) > 1 || Math.abs(Player.getY() - (stair.y + 0.5)) > 1 || Math.abs(Player.getZ() - stair.z) > 1)
{
// 移除矿车
stair.sitting = false;
Entity.remove(stair.minecart);
stair.minecart = null;
}
}
// 死亡不掉落
if(options.configs.Default.KeepInv)
{
if(inventory.isDead && Entity.getHealth(Player.getEntity()) > 0)
{
inventory.isDead = false;
for(i = 0; i < 36; i++)
{
Player.addItemInventory(inventory.id[i], inventory.count[i], inventory.data[i]);
}
Player.setLevel(inventory.level);
Player.setExp(inventory.xp);
}
}
//粒子特效
if(particle.open)
{
//玩家位置
var x=Player.getX();
var y=Player.getY()-1.2;
var z=Player.getZ();
//粒子效果
var px = 0.5 * Math.cos(pangle);
var pz = 0.5 * Math.sin(pangle);
if(x > 0 && z > 0)
{
px = x + px;
pz = z + pz;
}
else if(x < 0 && z  > 0)
{
px = x - px;
pz = z + pz;
}
else if(x < 0 && z < 0)
{
px = x - px;
pz = z - pz;
}
else if(x > 0 && z < 0)
{
px = x + px;
pz = z - pz;
}
Level.addParticle(pid,px,y,pz,pspeed,pspeed,pspeed,psize);
if(pangle < 360)
{
pangle++;
}
else
{
pangle = 0;
}
}
// 重力感应
if(sensor.open) Entity.setRot(Player.getEntity(), Entity.getYaw(Player.getEntity()) - sensor.x * 180 / Math.PI / 10, Entity.getPitch(Player.getEntity()) + sensor.y * 180 / Math.PI / 10);
// 修复创造虚空不死的bug
// PS: 这bug很古老了，本以为正式版修复了。。。结果呢，我大mojang干啥去了。。。
if(Player.getY() < -32) Player.setHealth(0);
}
// ================================
/** useItem 启动器钩子函数，当使用物品时触发
 * 参数: int x 点击的方块的x坐标
 *       int y 点击的方块的y坐标
 *       int z 点击的方块的z坐标
 *       int itemId 点击的物品id
 *       int blockId 点击的方块id
 *       int side 点击的方块的侧面
 *       int itemDamage 点击的物品的数据值
 *       int blockDamage 点击的方块的数据值
 */
function useItem(x, y, z, itemId, blockId, side, itemDamage, blockDamage)
{
if(build.point == SELECT.none)
{
// 挖石机
if(Level.getTile(x,y,z) == BLOCK_LIST.stone_digger.id && !((itemId == BLOCK_LIST.chest.id || itemId == BLOCK_LIST.trapped_chest.id) && side == 1))
{
var flag = false;
for(i in stoneDiggers)
{
// 如果数组中有此挖石机
if(stoneDiggers[i][0] == x && stoneDiggers[i][1] == y && stoneDiggers[i][2] == z)
{
preventDefault();
flag = true;
stoneDiggers.splice(i, 1);
break;
}
}
// 如果数组中没有此挖石机
if(!flag)
{
preventDefault();
stoneDiggers.push(new Array(x, y, z));
}
// 播放声音
Level.playSound(x, y, z, "random.click", 1, 0.5);
}
// 快速砍树
if(options.configs.Default.FastCutWood && ITEM_LIST.AXE.contains(itemId) && BLOCK_LIST.WOOD.contains(blockId))
{
preventDefault();
// 处理一下数据值
var iBDamage = blockDamage >= 8 ? blockDamage - 8 : ((blockDamage >= 4 && blockDamage < 8) ? blockDamage - 4 : blockDamage);
// 用for循环判断上方是否是原木
for(var i = 0; i < 128; i++)
{
if(Level.getTile(x, y + i, z) == 17 || Level.getTile(x, y + i, z) == 162)
{
Level.destroyBlock(x, y + i, z, false);
Level.dropItem(x, y + i, z, 0, blockId, 1, iBDamage);
}
else break;
}
}
// 桶点黑曜石变岩浆
if(options.configs.Default.TurnLava && itemId == 325 && itemDamage == 0 && blockId == 49)
{
preventDefault();
Entity.setCarriedItem(Player.getEntity(), 325, Player.getCarriedItemCount() - 1, 0);
Player.addItemInventory(325, 1, 10);
Level.setTile(x, y, z, 0, 0);
clientMessage(language.prefix + language.turn_lava);
}
// 椅子
if(options.configs.Default.StairEnabled && !stair.sitting && BLOCK_LIST.STAIRS.contains(blockId) && blockDamage < 4)
{
preventDefault();
// 记录矿车位置
stair.x = x + 0.5;
stair.y = y + 1;
stair.z = z + 0.5;
// 记录yaw(n,s,e,w对应3,2,0,1)
switch(blockDamage)
{
default:
case 3:
var yaw = 0;
break;
case 2:
var yaw = 180;
break;
case 0:
var yaw = 90;
break;
case 1:
var yaw = 270;
break;
}
// 召唤一个矿车
stair.minecart = Level.spawnMob(stair.x, stair.y, stair.z, 84, "entity/minecart.png");
// 使它不可见
Entity.setRenderType(stair.minecart, 4);
// 让玩家骑上它
Entity.rideAnimal(Player.getEntity(), stair.minecart);
Entity.setRot(Player.getEntity(), yaw, Entity.getPitch(Player.getEntity()));
stair.sitting = true;
}
// 在此添加其他
}
else if(itemId == SELECT.tool)
{
// 选点
preventDefault();
build.x[build.select] = x, build.y[build.select] = y, build.y[build.select] = y;
build.select++;
if(build.select >= build.point) createGeometry();
toast("已选择点" + build.select);
}
}
// ================================
/** destroyBlock 启动器钩子函数，当破坏方块时触发
 * 参数: int x 方块的x坐标
 *       int y 方块的y坐标
 *       int z 方块的z坐标
 *       int side 方块的一面(请参考启动器函数表)
 */
function destroyBlock(x, y, z, side)
{
if(/*记得以前创造拿剑破坏方块也会触发这个函数的,没想到现在也是*/!(Level.getGameMode() == 1 && (Player.getCarriedItem() == 268 || Player.getCarriedItem() == 272 || Player.getCarriedItem() == 267 || Player.getCarriedItem() == 283 || Player.getCarriedItem() == 276)))
{
if(Level.getTile(x, y, z) == BLOCK_LIST.stone_digger.id)
{
for(var i in stoneDiggers)
{
// 如果数组中有此挖石机
if(stoneDiggers[i][0] == x && stoneDiggers[i][1] == y && stoneDiggers[i][2] == z)
{
stoneDiggers.splice(i, 1);
break;
}
}
}
if(options.configs.Default.FastHarvest)
{
if(Level.getTile(x, y, z) == 59)
fastDestroyBlocks(x, y, z, Level.getTile(x, y, z));
}
}
}
// ================================
/** explodeHook 启动器钩子函数，当有爆炸发生时触发
 * 参数: entity entity 发生爆炸的实体
 *       double x 实体的x坐标
 *       double y 实体的y坐标
 *       double z 实体的z坐标
 *       double power 实体爆炸的威力
 *       boolean onFire 是否着火???(猜的)
 */
function explodeHook(entity, x, y, z, power, onFire)
{
if(options.configs.Default.AntiBomb)
{
preventDefault();
//Level.explode(x, y, z, power, true, true, 0);
}
}
// ================================
/** entityAddedHook 启动器钩子函数，当有实体生成时触发
 * 参数: entity entity 生成的实体
 */
function entityAddedHook(entity)
{
var entityId = Entity.getEntityTypeId(entity);
if(options.configs.Default.KillEnderman && entityId == 38) Entity.remove(entityId);
}
// ================================
/** attackHook 启动器钩子函数，当有实体被攻击时触发
 * 参数: entity attacker 攻击者
 *       entity victim 被攻击者
 */
function attackHook(attacker, victim)
{
if(Player.getCarriedItem() == 500)
{
Entity.setHealth(victim, Entity.getHealth(victim) - 6);
Level.addParticle(23, Entity.getX(victim), Entity.getY(victim), Entity.getZ(victim), 4, 4, 4, 9);
}
}
// ================================
/** deathHook 启动器钩子函数，当有实体死亡时触发
 * 参数: entity attacker 攻击者
 *       entity entity 死亡的实体
 */
function deathHook(attacker, entity)
{
if(options.configs.Default.KeepInv)
{
if(entity == Player.getEntity())
{
inventory = {
isDead: true,
id: [],
data: [],
count: [],
ench: [],
level: 0,
xp: 0
};

for(i = 0; i < 36; i++)
{
inventory.id.push(Player.getInventorySlot(i));
inventory.data.push(Player.getInventorySlotData(i));
inventory.count.push(Player.getInventorySlotCount(i));
Player.clearInventorySlot(i);
}

inventory.level = Player.getLevel();
inventory.xp = Player.getExp();
Player.setLevel(0);
Player.setExp(0);
}
}
}
// ================================
/** screenChangeHook 启动器钩子函数，当屏幕改变时触发
 * 参数: string screenName Gui的名字
 */
function screenChangeHook(screenName)
{
//toast(screenName);
save(JS_DIR, "test.txt", true, screenName + "\n");
}
// ================================
/** leaveGame 启动器钩子函数，当退出存档时触发
 */
function leaveGame()
{
isInGame = false;
// 保存配置文件
saveGlobalSettings();
saveWorldSettings();
// 删除GUI
ctx.runOnUiThread(new java.lang.Runnable({run: function(){
for(var i in gui)
{
if(gui[i] != null) gui[i].dismiss();
}
}}));
}
// ================================
/** GUI */
/** openMainMenu 打开主菜单
 * 作者: QingChenW
 */
function openMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "空岛帮手菜单", size: 23, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));
var text = createText(layout, {text: "作者 QingChenW", size: 17, color: android.graphics.Color.LTGRAY});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 20), 0, 0, 0));
createButton(layout, {text: "空岛菜单", size: 21}, {click: new android.view.View.OnClickListener(){onClick: function(view){
openIslandMenu();
}}});
createButton(layout, {text: "挑战任务", size: 21}, {click: new android.view.View.OnClickListener(){onClick: function(view){
openChallengeMenu();
}}});
createButton(layout, {text: "迷你商店", size: 21}, {click: new android.view.View.OnClickListener(){onClick: function(view){
openMinishopMenu();
}}});
createButton(layout, {text: "传送点", size: 21}, {click: new android.view.View.OnClickListener(){onClick: function(view){
openWarpMenu();
}}});
createButton(layout, {text: "更多功能", size: 21}, {click: new android.view.View.OnClickListener(){onClick: function(view){
openToolMenu();
}}});
createButton(layout, {text: "作弊菜单", size: 21}, {click: new android.view.View.OnClickListener(){onClick: function(view){
openCheatMenu();
}}});
createButton(layout, {text: "建造菜单", size: 21}, {click: new android.view.View.OnClickListener(){onClick: function(view){
openBuildMenu();
}}});
createButton(layout, {text: "彩蛋菜单", size: 21}, {click: new android.view.View.OnClickListener(){onClick: function(view){
openColoreggMenu();
}}});
createButton(layout, {text: "设置菜单", size: 21}, {click: new android.view.View.OnClickListener(){onClick: function(view){
openSettingMenu();
}}});
createButton(layout, {text: "关于", size: 21}, {click: new android.view.View.OnClickListener(){onClick: function(view){
about();
}}});

createPopupWindow(createScrollView(layout), {width: getWidth() * 0.25, height: getHeight(), background: new android.graphics.drawable.ColorDrawable(android.graphics.Color.argb(127, 0, 0, 0)),
 focusable: true, gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: 0, y: 0});
}
catch(error)
{
print(error);
}
}
// ================================
/** openIslandMenu 打开空岛菜单
 * 作者: QingChenW
 */
function openIslandMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "空岛菜单", size: 21, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));
createButton(layout, {text: "空岛生涯", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
islandStart();
}}});
createButton(layout, {text: "空岛等级", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
islandLevel();
}}});
createButton(layout, {text: "空岛成员", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
islandMember();
}}});
var reset = false;
var button = createButton(layout, {text: "重置空岛", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
if(!reset)
{
reset = true;
clientMessage(language.prefix+"您真的要重置岛屿吗？再点击一次按钮确认。");
button.setText("您确定吗");
}
else islandReset();
}}});

createPopupWindow(createScrollView(layout), {width: getWidth() * 0.2, height: getHeight(), background: new android.graphics.drawable.ColorDrawable(android.graphics.Color.argb(63, 0, 0, 0)),
 focusable: true, gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: getWidth() * 0.25, y: 0});
}
catch(error)
{
print(error);
}
}

function islandStart()
{
if(!worldOptions.island.HaveIsland)
{
clientMessage(language.prefix+"开始初始化空岛生存。");
worldOptions.island = {
HaveIsland: false,// 怕初始化失败所以创建完岛屿再设置为true
ResetTimes: 3,
Level: 0,
PosX: parseInt(Player.getX()),
PosY: 65,
PosZ: parseInt(Player.getZ())
};
createIsland();
saveWorldSettings();
clientMessage(language.prefix+"岛屿创建成功，尽情游玩吧。");
}
else
{
clientMessage(language.prefix+"您已经拥有了一个岛屿，请通过传送点菜单返回岛屿。");
}
}

function islandLevel()
{
if(worldOptions.island.HaveIsland)
{
clientMessage(language.prefix+"正在计算岛屿等级，卡顿属于正常现象，请勿担心。");
var thread = new java.lang.Thread(new java.lang.Runnable(){run: function(){
var x1 = worldOptions.island.PosX - 128;
var y1 = 0;
var z1 = worldOptions.island.Posz - 128;
var x2 = worldOptions.island.PosX + 128;
var y2 = 128;
var z2 = worldOptions.island.Posz + 128;
islevel = 0;
for(var xi = 0;x1 + xi <= x2;xi++)
{
for(var yi = 0;y1 + yi <= y2;yi++)
{
for(var zi = 0;z1 + zi <= z2;zi++)
{
if(Level.getTile(x1+xi,y1+yi,z1+zi) != 0) islevel++;
}
}
}
worldOptions.island.Level = islevel;
saveWorldSettings();
clientMessage(language.prefix+"您的岛屿等级为 "+worldOptions.island.Level+" 级。");
}});
thread.start();
}
else
{
clientMessage(language.prefix+"您还没有开始岛屿生涯哦。");
}
}

function islandMember()
{
if(worldOptions.island.HaveIsland)
{

}
else
{
clientMessage(language.prefix+"您还没有开始岛屿生涯哦。");
}
}

function islandReset()
{
if(worldOptions.island.HaveIsland)
{
if(worldOptions.island.ResetTimes > 0)
{
clientMessage(language.prefix+"开始重置岛屿。");
createIsland();
worldOptions.island.ResetTimes--;
saveWorldSettings();
clientMessage(language.prefix+"岛屿已重置，您还剩下"+worldOptions.island.ResetTimes+"次重置机会。");
}
else
{
clientMessage(language.prefix+"您的机会已用光，不能再重置岛屿了。");
}
}
else
{
clientMessage(language.prefix+"您还没有开始岛屿生涯哦。");
}
}

function createIsland()
{
var dialog = createProgressDialog(null, {title: "空岛生成中...", message: "正在准备开始空岛生涯", max: 16, cancelable: false, touchCancelable: false});

var thread = new java.lang.Thread(new java.lang.Runnable(){run: function(){
// 加载区块
dialog.setMessage("正在计算周围区块...");
var chuckX = Math.ceil(worldOptions.island.PosX / 16), chuckZ = Math.ceil(worldOptions.island.PosZ / 16);
var chuckList = [[chuckX, chuckZ],[chuckX + 1, chuckZ],[chuckX, chuckZ + 1],[chuckX - 1, chuckZ],[chuckX, chuckZ - 1],[chuckX + 1, chuckZ + 1],[chuckX + 1, chuckZ - 1],[chuckX - 1, chuckZ + 1],[chuckX - 1, chuckZ - 1]];//尚未完全实现
dialog.incrementProgressBy(1);
// 清空周围九个区块
dialog.setMessage("正在清空周围⑨个区块...");
createSquare(null, chuckList[0][0] * 16, 0, chuckList[0][1] * 16, chuckList[0][0] * 16 - 16, 128, chuckList[0][1] * 16 - 16, 0, 0);
dialog.incrementProgressBy(1);
// 打开区块生成器
dialog.setMessage("正在打开区块生成器...");
dialog.incrementProgressBy(1);
// 生成空岛
dialog.setMessage("正在生成空岛...");
spawnIsland(worldOptions.island.PosX, worldOptions.island.PosY, worldOptions.island.PosZ);
dialog.incrementProgressBy(1);
// 清空背包
dialog.setMessage("正在清空背包...");
for(var i = 9;i <= 44;i++) Player.clearInventorySlot(i);
dialog.incrementProgressBy(1);
// 设置坐标
dialog.setMessage("正在设置坐标...");
worldOptions.warps.IslandHome = {x: worldOptions.island.PosX + 0.5, y: worldOptions.island.PosY + 7, z: worldOptions.island.PosZ - 1.5};
dialog.incrementProgressBy(1);
Level.setSpawn(worldOptions.warps.IslandHome.x, worldOptions.warps.IslandHome.y, worldOptions.warps.IslandHome.z);
dialog.incrementProgressBy(1);
Entity.setPosition(Player.getEntity(), worldOptions.warps.IslandHome.x, worldOptions.warps.IslandHome.y, worldOptions.warps.IslandHome.z);
dialog.incrementProgressBy(1);
// 切换为生存
dialog.setMessage("正在切换为生存...");
Level.setGameMode(0);
dialog.incrementProgressBy(1);
// 修改变量
worldOptions.island.HaveIsland = true;
dialog.dismiss();
}});

dialog.show();
thread.start();
}
// ================================
function openChallengeMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "挑战任务", size: 21, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));
for(var i in worldOptions.challenge)
{
createButton(layout, {text: worldOptions.challenge[i].Name}, {click: new android.view.View.OnClickListener(){onClick: function(view){
if(worldOptions.island.HaveIsland)
{
for(var j in worldOptions.challenge[i])
{

}
/*for(var slot = 9;slot <= 44;slot++)
{
if(Player.getInventorySlot(slot) == 4 && Player.getInventorySlotCount(islot) == 64)
{
Player.clearInventorySlot(islot);
Player.addItemInventory(388,1,0);
clientMessage(language.prefix+"恭喜玩家"+Player.getName(Player.getEntity())+"完成任务:圆石收集者！获得1个绿宝石！");
break;
}
}
if(islot > 35)
{
clientMessage(language.prefix+"这个任务需要64个圆石来完成哦！");
}
}*/
}
else
{
clientMessage(language.prefix+"您还没有开始岛屿生涯。");
}
}}});
}
createPopupWindow(createScrollView(layout), {width: getWidth() * 0.2, height: getHeight(), background: android.graphics.Color.argb(63, 0, 0, 0),
 focusable: true, gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: getWidth() * 0.25, y: 0});
}
catch(error)
{
print(error);
}
}
// ================================
function openMinishopMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "商店菜单", size: 21, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));

createPopupWindow(createScrollView(layout), {width: getWidth() * 0.2, height: getHeight(), background: android.graphics.Color.argb(63, 0, 0, 0),
 focusable: true, gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: getWidth() * 0.25, y: 0});
}
catch(error)
{
print(error);
}
}
// ================================
function openWarpMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "传送点", size: 21, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));
//回到空岛
createButton(layout, {text: "回到空岛", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
if(worldOptions.island.HaveIsland)
{
Entity.setPosition(Player.getEntity(), worldOptions.warps.IslandHome[0], worldOptions.warps.IslandHome[1], worldOptions.warps.IslandHome[2]);
clientMessage(language.prefix+"回到你的岛屿。");
}
else
{
clientMessage(language.prefix+"您还没有开始岛屿生涯，将为您创建岛屿。");
spawnisland();
}
}}});
//设置空岛传送点
createButton(layout, {text: "设置空岛传送点", size: 15}, {click: new android.view.View.OnClickListener(){onClick: function(view){
if(worldOptions.island.HaveIsland)
{
worldOptions.warps.IslandHome = [parseFloat(Player.getX()), parseFloat(Player.getY()), parseFloat(Player.getZ())];
saveWorldOptions();
clientMessage(language.prefix+"设置岛屿的家在您脚下。");
}
else
{
clientMessage(language.prefix+"您还没有开始岛屿生涯。");
}
}}});
//回家
createButton(layout, {text: "回到家", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
if(!worldOptions.warps.Home[0].isNaN())
{
Entity.setPosition(Player.getEntity(), worldOptions.warps.Home[0], worldOptions.warps.Home[1], worldOptions.warps.Home[2]);
clientMessage(language.prefix+"传送到你的家。");
}
else
{
clientMessage(language.prefix+"你还没有设置家。");
}
}}});
//设置家
var button = createButton(layout, {text: "设置家", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
worldOptions.warps.Home = [parseFloat(Player.getX()), parseFloat(Player.getY()), parseFloat(Player.getZ())];
saveWorldOptions();
clientMessage(language.prefix+"设置家在您脚下。");
}}});
// 地标
for(var i in worldOptions.warps)
{
//if(i == "" || i == "")// 额其实想做一块去的,新特性
createButton(layout, {text: worldOptions.warps[i][3], size: 15}, {click: new android.view.View.OnClickListener(){onClick: function(view){
Entity.setPosition(Player.getEntity(), worldOptions.warps[i][0], worldOptions.warps[i][1], worldOptions.warps[i][2]);
clientMessage(language.prefix+"传送到地标："+worldOptions.warps[i][3]);
}}});
}

createPopupWindow(createScrollView(layout), {width: getWidth() * 0.2, height: getHeight(), background: android.graphics.Color.argb(63, 0, 0, 0),
 focusable: true, gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: getWidth() * 0.25, y: 0});
}
catch(error)
{
print(error);
}
}
// ================================
/** openToolMenu 打开功能菜单
 * 作者: QingChenW
 */
function openToolMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "更多功能", size: 21, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));

createToggleButton(layout, {textOn: "MP3播放器开", textOff: "MP3播放器关", size: 15, isChecked: options.configs.Default.MP3Player}, {click: new android.view.View.OnClickListener(){onClick: function(){
if(!options.configs.Default.OpenMP3)
{
openMP3Player();
options.configs.Default.OpenMP3 = true;
}
else
{
// close MP3
options.configs.Default.OpenMP3 = false;
}
saveGlobalSettings();
}}});
createToggleButton(layout, {textOn: "信息显示开", textOff: "信息显示关", size: 17, isChecked: options.configs.Default.MoreInfo}, {click: new android.view.View.OnClickListener(){onClick: function(){
if(!options.configs.Default.MoreInfo) options.configs.Default.MoreInfo = true;
else options.configs.Default.MoreInfo = false;
saveGlobalSettings();
}}});
createToggleButton(layout, {textOn: "小地图开", textOff: "小地图关", size: 17, isChecked: options.configs.Default.MiniMap}, {click: new android.view.View.OnClickListener(){onClick: function(){
if(!options.configs.Default.MiniMap) options.configs.Default.MiniMap = true;
else options.configs.Default.MiniMap = false;
saveGlobalSettings();
}}});
createToggleButton(layout, {textOn: "显血开", textOff: "显血关", size: 17, isChecked: options.configs.Default.ShowHealth}, {click: new android.view.View.OnClickListener(){onClick: function(){
if(!options.configs.Default.ShowHealth) options.configs.Default.ShowHealth = true;
else options.configs.Default.ShowHealth = false;
saveGlobalSettings();
}}});
createToggleButton(layout, {textOn: "快速砍树开", textOff: "快速砍树关", size: 17, isChecked: options.configs.Default.FastCutWood}, {click: new android.view.View.OnClickListener(){onClick: function(){
if(!options.configs.Default.FastCutWood) options.configs.Default.FastCutWood = true;
else options.configs.Default.FastCutWood = false;
saveGlobalSettings();
}}});
createToggleButton(layout, {textOn: "一键收割开", textOff: "一键收割关", size: 17, isChecked: options.configs.Default.FastHarvest}, {click: new android.view.View.OnClickListener(){onClick: function(){
if(!options.configs.Default.FastHarvest) options.configs.Default.FastHarvest = true;
else options.configs.Default.FastHarvest = false;
saveGlobalSettings();
}}});
createToggleButton(layout, {textOn: "黑曜石回收开", textOff: "黑曜石回收关", size: 15, isChecked: options.configs.Default.TurnLava}, {click: new android.view.View.OnClickListener(){onClick: function(){
if(!options.configs.Default.TurnLava) options.configs.Default.TurnLava = true;
else options.configs.Default.TurnLava = false;
saveGlobalSettings();
}}});
createToggleButton(layout, {textOn: "移动光源开", textOff: "移动光源关", size: 15, isChecked: options.configs.Default.MoveLights}, {click: new android.view.View.OnClickListener(){onClick: function(){
if(!options.configs.Default.MoveLights) options.configs.Default.MoveLights = true;
else options.configs.Default.MoveLights = false;
saveGlobalSettings();
}}});
createToggleButton(layout, {textOn: "望远镜开", textOff: "望远镜关", size: 17, isChecked: options.configs.Default.ZoomIn}, {click: new android.view.View.OnClickListener(){onClick: function(view){
if(!options.configs.Default.ZoomIn)
{
options.configs.Default.ZoomIn = true;
zoomInFov();
}
else
{
options.configs.Default.ZoomIn = false;
if(gui.zoom != null)
{
gui.zoom.dismiss();
gui.zoom = null;
}
}
saveGlobalSettings();
}}});

createCheckBox(layout, {text: "死亡不掉落", size: 13, isChecked: options.configs.Default.KeepInv}, {change: new android.widget.CompoundButton.OnCheckedChangeListener(){onCheckedChanged: function(view, isChecked){
if(!options.configs.Default.KeepInv) options.configs.Default.KeepInv = true;
else options.configs.Default.KeepInv = false;
saveGlobalSettings();
}}});
createCheckBox(layout, {text: "防爆", size: 13, isChecked: options.configs.Default.AntiBomb}, {change: new android.widget.CompoundButton.OnCheckedChangeListener(){onCheckedChanged: function(view, isChecked){
if(!options.configs.Default.AntiBomb) options.configs.Default.AntiBomb = true;
else options.configs.Default.AntiBomb = false;
saveGlobalSettings();
}}});
createCheckBox(layout, {text: "禁止刷小黑", size: 13, isChecked: options.configs.Default.KillEnderman}, {change: new android.widget.CompoundButton.OnCheckedChangeListener(){onCheckedChanged: function(view, isChecked){
if(!options.configs.Default.KillEnderman) options.configs.Default.KillEnderman = true;
else options.configs.Default.KillEnderman = false;
saveGlobalSettings();
}}});

createPopupWindow(createScrollView(layout), {width: getWidth() * 0.2, height: getHeight(), background: android.graphics.Color.argb(63, 0, 0, 0),
 focusable: true, gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: getWidth() * 0.25, y: 0});
}
catch(error)
{
print(error);
}
}

/** openMP3Player 打开MP3播放器
 * 作者: QingChenW
 * 备注: music = {player, }
 */
function openMP3Player()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

// 新建一个播放器
music.player = new android.media.MediaPlayer();
music.player.setOnCompletionListener(new android.media.MediaPlayer.OnCompletionListener({
onCompletion: function(mp){
// 播放完毕事件
if(music.replay)
{
music.mediaPC.start();
}
else
{
music.player.release();
if(options.configs.Default.MusicList[music.current++] != undefined) music.current++;
else music.current = 0;
music.player.setDataSource(options.configs.Default.MusicList[music.current]);
music.player.prepare();
music.player.start();
music.status.setText("正在播放: " + options.configs.Default.MusicList[music.current]);
}
}}));
music.player.setOnErrorListener(new android.media.MediaPlayer.OnCompletionListener({
onError: function(mp, what, extra){
music.player.release();
print("错误,请检查歌曲列表");
}}));

// MP3播放器标题栏
var layout2 = new android.widget.LinearLayout(ctx);
var title = createText(layout2, "高大上一点点的MP3播放器", 21, null, android.graphics.Color.rgb(255, 255, 255));
var button = createButton(layout2, "播放列表", 21, null);
button.setOnClickListener(new android.view.View.OnClickListener(){onClick: function(view){
openMusicList();
}});
var button = createButton(layout2, "-", 21, null);
button.setOnClickListener(new android.view.View.OnClickListener(){onClick: function(view){
hideMP3Player();
}});
layout.addView(layout2);

music.status = createText(layout, "未播放音乐...", 19, null, android.graphics.Color.rgb(255, 255, 255));
music.lyric = createText(layout, "歌词功能尚未制作,尽请期待...", 17, null, android.graphics.Color.rgb(255, 255, 255));
music.controller = new Android.widget.MediaController(ctx);
music.controller.setAnchorView(layout);
music.mediaPC = new android.widget.MediaController.MediaPlayerControl()
{
start: function(){
if(!music.player.isPlaying())
{
music.player.setDataSource(options.configs.Default.MusicList[music.current]);
music.player.prepare();
}
music.player.start();
music.status.setText("正在播放: " + options.configs.Default.MusicList[music.current]);
},
pause: function(){
if(music.player.isPlaying())
{
music.player.pause();
}
},
getDuration: function(){

},
getCurrentPosition: function(){

},
seekTo: function(pos){
music.player.seekTo(pos);
},
isPlaying: function(){

},
getBufferPercentage: function(){

},
canPause: function(){

},
canSeekBackward: function(){

},
canSeekForward: function(){

}
};
music.controller.setMediaPlayer(mediaPC);

var x = getWidth() * 0.5 - dip2px(ctx, 80), y = dip2px(ctx, 20), mX, mY;
gui.mp3 = createPopupWindow(layout, dip2px(ctx, 80), dip2px(ctx, 40), android.graphics.Color.argb(63, 0, 0, 0), true, true);
gui.mp3.setOnTouchListener(new android.view.View.OnTouchListener(
{
onTouch :function(view, event)
{
switch (e.getAction())
{
case 0:
mX = e.getX();
mY = e.getY();
break;
case 2:
var delX = parseFloat(e.getX() - mX);
var delY = parseFloat(e.getY() - mY);
x = x + delX;
y = y + delY;
gui.mp3.update(parseFloat(x), parseFloat(y), -1, -1);
break;
}
return true;
}
}));
gui.mp3.showAtLocation(ctx.getWindow().getDecorView(), android.view.Gravity.TOP, x, y);
}
catch(error)
{
print(error);
}
}

function hideMP3Player()
{

}

function openMusicList()
{

}

function playMusic(path)
{
if(mp3 != null && mp3.isPlaying())
{
mp3.stop();
mp3.release();
mp3=null;
}
mp3=new android.media.MediaPlayer();
mp3.setDataSource(music);
mp3.prepare();
mp3.start();


}

function fileViewer(path)
{

}

function openMiniMap()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);
var x = 56, y = 48, oldX, oldY;

//var pos = createText(layout, {text: "X:"+parseInt(Player.getX())+" Y:"+parseInt(Player.getY()-1)+" Z:"+parseInt(Player.getZ()),
//                                           size: 14, gravity: 17, color: android.graphics.Color.WHITE});

createPopupWindow(layout, {width: dip2px(ctx,128), height: dip2px(ctx,144), background: android.graphics.Color.argb(31, 0, 0, 0),
 gravity: android.view.Gravity.LEFT | android.view.Gravity.TOP, x: x, y: y}).setOnTouchListener(new android.view.View.OnTouchListener({onTouch: function(view, event){
switch(event.getAction())
{
case android.view.MotionEvent.ACTION_DOWN:
oldX = e.getX();
oldY = e.getY();
break;
case android.view.MotionEvent.ACTION_MOVE:
x += parseFloat(e.getX() - oldX);
y += parseFloat(e.getY() - oldY);
mapop.update(parseFloat(x), parseFloat(y), -1, -1);
break;
}
return true;
}}));
updateMap();
}
catch(error)
{
print(error);
}
}

function updateMap()
{
new android.os.Handler().postDelayed(new java.lang.Runnable(
{
run: function() 
{
if(options.configs.Default.MiniMap)
{
pos.setText("X:"+parseInt(Player.getX())+" Y:"+parseInt(Player.getY()-1)+" Z:"+parseInt(Player.getZ()));
updateMap();
}
}
}), 400);
}


function zoomInFov()
{
try
{
var layout = new android.widget.RelativeLayout(ctx);

var button = createButton(layout, {text: "+"});
button.setOnTouchListener(new android.view.View.OnTouchListener({onTouch: function(view, event){
switch(event.getAction())
{
case android.view.MotionEvent.ACTION_DOWN:
ModPE.setFov(24);
break;
case android.view.MotionEvent.ACTION_UP:
ModPE.resetFov();
break;
}
return true;
}}));

gui.zoom = createPopupWindow(layout, {width: dip2px(ctx, 96), height: dip2px(ctx, 96),
 gravity: android.view.Gravity.LEFT | android.view.Gravity.BOTTOM, x: 0, y: dip2px(ctx, 384)});
}
catch(error)
{
print(error);
}
}

/*均使用延时函数
// 更多信息
if(options.configs.Default.MoreInfo) updateMoreInfo();
// 小地图
if(options.configs.Default.MiniMap) updateMiniMap();
// 显血
if(options.configs.Default.ShowHealth) updateHealthView();
*/
// ================================
function openCheatMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "作弊菜单", size: 21, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));

//给予物品
createButton(layout, {text: "获得物品", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
giveItemMenu();
}}});
//修改附魔
createButton(layout, {text: "修改附魔", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
enchantMenu();
}}});
//生成实体
createButton(layout, {text: "生成实体", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
entityMenu();
}}});
//药水效果
createButton(layout, {text: "药水效果", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
potionMenu();
}}});
//游戏模式
createButton(layout, {text: "游戏模式", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
gameModeMenu();
}}});
//游戏时间
createButton(layout, {text: "游戏时间", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
gameTimeMenu();
}}});
//游戏天气
createButton(layout, {text: "游戏天气", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
gameWeatherMenu();
}}});
//传送
createButton(layout, {text: "玩家位置", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
changePos();
}}});
//变速
createButton(layout, {text: "变速", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
changeSpeed();
}}});

createPopupWindow(createScrollView(layout), {width: getWidth() * 0.2, height: getHeight(), background: android.graphics.Color.argb(63, 0, 0, 0),
 focusable: true, gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: getWidth() * 0.25, y: 0});
}
catch(error)
{
print(error); 
}
}

function giveItemMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "物品菜单", size: 19, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));

//全部物品
createButton(layout, {text: "全部物品", size: 17}, {click: new android.view.View.OnClickListener(){onClick: function(view){
moreItems();
}}});
//用ID获得
createButton(layout, {text: "添加物品", size: 17}, {click: new android.view.View.OnClickListener(){onClick: function(view){
tooManyItems();
}}});
//背包
createButton(layout, {text: "清空背包", size: 17}, {click: new android.view.View.OnClickListener(){onClick:function(view){
for(var slot = 9; slot <= 44; slot++) Player.clearInventorySlot(slot);
}}});

createPopupWindow(createScrollView(layout), {width: getWidth() * 0.15, height: getHeight(), background: android.graphics.Color.argb(31, 0, 0, 0),
 focusable: true, gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: getWidth() * 0.45, y: 0});
}
catch(error)
{
print(error);
}
}

function tooManyItems()
{
const number = android.text.InputType.TYPE_CLASS_NUMBER;
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var editId = createEditText(layout, {text: "序号: ", hint: "输入物品序号(ID)", inputType: number});
var editCount = createEditText(layout, {text: "数量: ", hint: "输入物品数量", inputType: number});
var editData = createEditText(layout, {text: "数据值: ", hint: "输入物品特殊数据值(损伤值)", inputType: number});
createButton(layout, {text: "添加物品"}, {click: new android.view.View.OnClickListener(){onClick: function(view){
var id = editId.getText();
var count = editCount.getText();
var data = editData.getText();

if(id == "") id = 0;
if(count <= 0 || count > 64) count = 1;
if(data == "") data = 0;

if(Level.getGameMode() == 0) Player.addItemInventory(id, count, data);
else if(Level.getGameMode() == 1) Entity.setCarriedItem(Player.getEntity(), id, count, data);
clientMessage(language.prefix+"给予玩家 "+id+":"+count+" X"+data+"！");

dialog.dismiss();
}}});

var dialog = createDialog(layout, {title: "直接添加物品"});
dialog.show();
}
catch(error)
{
print(error);
}
}

function gameModeMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "游戏模式", size: 19, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));
//生存
createButton(layout, {text: "生存", size: 17}, {click: new android.view.View.OnClickListener(){onClick: function(view){
Level.setGameMode(0);
clientMessage(language.prefix+"您的游戏模式已更新为生存！");
}}});
//创造
createButton(layout, {text: "创造", size: 17}, {click: new android.view.View.OnClickListener(){onClick: function(view){
Level.setGameMode(1);
clientMessage(language.prefix+"您的游戏模式已更新为创造！");
}}});
//飞行
createCheckBox(layout, {text: "飞行", size: 13, isChecked: Player.canFly()}, {change: new android.widget.CompoundButton.OnCheckedChangeListener(){onCheckedChanged: function(view, isChecked){
if(isChecked){Player.setCanFly(true);
clientMessage(language.prefix+"飞行已开启。");}
else{Player.setCanFly(false);
clientMessage(language.prefix+"飞行已关闭。");}
}}});

createPopupWindow(createScrollView(layout), {width: getWidth() * 0.15, height: getHeight(), background: android.graphics.Color.argb(31, 0, 0, 0), focusable: true,
 gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: getWidth() * 0.45, y: 0});
}
catch(error)
{
print(error);
}
}

function gameTimeMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "游戏时间", size: 19, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));
//清晨
createButton(layout, {text: "清晨", size: 17}, {click: new android.view.View.OnClickListener(){onClick: function(view){
Level.setTime(0);
clientMessage(language.prefix+"您的游戏时间已设置为清晨！");
}}});
//正午
createButton(layout, {text: "正午", size: 17}, {click: new android.view.View.OnClickListener(){onClick: function(view){
Level.setTime(6000);
clientMessage(language.prefix+"您的游戏时间已设置为正午！");
}}});
//傍晚
createButton(layout, {text: "傍晚", size: 17}, {click: new android.view.View.OnClickListener(){onClick: function(view){
Level.setTime(12000);
clientMessage(language.prefix+"您的游戏时间已设置为傍晚！");
}}});
//午夜
createButton(layout, {text: "午夜", size: 17}, {click: new android.view.View.OnClickListener(){onClick: function(view){
Level.setTime(18000);
clientMessage(language.prefix+"您的游戏时间已设置为午夜！");
}}});

createPopupWindow(createScrollView(layout), {width: getWidth() * 0.15, height: getHeight(), background: android.graphics.Color.argb(31, 0, 0, 0), focusable: true,
 gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: getWidth() * 0.45, y: 0});
}
catch(error)
{
print(error);
}
}

function gameWeatherMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "游戏天气", size: 19, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));

//无
createButton(layout, {text: "晴天", size: 17}, {click: new android.view.View.OnClickListener(){onClick: function(view){
Level.setLightningLevel(0);
Level.setRainLevel(0);
clientMessage(language.prefix+"天气已设置为晴朗！");
}}});
//下雨
createButton(layout, {text: "雨/雪天", size: 17}, {click: new android.view.View.OnClickListener(){onClick: function(view){
Level.setRainLevel(10);
Level.setLightningLevel(10);
clientMessage(language.prefix+"天气已设置为雨/雪！");
}}});
//雷阵雨
createButton(layout, {text: "雷阵雨", size: 17}, {click: new android.view.View.OnClickListener(){onClick: function(view){
Level.setLightningLevel(10);
Level.setRainLevel(10);
clientMessage(language.prefix+"天气已设置为雷阵雨！");
}}});

createPopupWindow(createScrollView(layout), {width: getWidth() * 0.15, height: getHeight(), background: android.graphics.Color.argb(31, 0, 0, 0), focusable: true,
 gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: getWidth() * 0.45, y: 0});
}
catch(error)
{
print(error);
}
}

function changePos()
{
const number = android.text.InputType.TYPE_CLASS_NUMBER | android.text.InputType.TYPE_NUMBER_FLAG_SIGNED;
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var editX = createEditText(layout, {text: "X: ", hint: "x坐标", inputType: number});
editX.setText(String(parseFloat(Player.getX())));
var editY = createEditText(layout, {text: "Y: ", hint: "y坐标", inputType: number});
editY.setText(String(parseFloat(Player.getY())));
var editZ = createEditText(layout, {text: "Z: ", hint: "z坐标", inputType: number});
editZ.setText(String(parseFloat(Player.getZ())));
createButton(layout, {text: "传送"}, {click: new android.view.View.OnClickListener(){onClick: function(view){
Entity.setPosition(Player.getEntity(), parseFloat(editX.getText()), parseFloat(editY.getText()), parseFloat(editZ.getText()));
dialog.dismiss();
}}});

var dialog = createDialog(layout, {title: "移动到坐标"});
dialog.show();
}
catch(error)
{
print(error);
}
}

function changeSpeed()
{
const number = android.text.InputType.TYPE_CLASS_NUMBER;
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var editTps = createEditText(layout, {text: "速度: ", hint: "默认速度(TPS)为20", inputType: number});
editTps.setText(String(20));
var seek = createSeekBar(layout, {max: 100, progress: parseInt(editTps.getText())}, {change: new android.widget.SeekBar.OnSeekBarChangeListener(){onStopTrackingTouch: function(view){
editTps.setText(String(seek.getProgress()));
}}});
createButton(layout, {text: "确认"}, {click: new android.view.View.OnClickListener(){onClick: function(view){
var tps = parseInt(editTps.getText());
if(tps > 0)
{
ModPE.setGameSpeed(tps);
clientMessage(language.prefix+"切换为普通速度的"+parseFloat(tps / 20) + "倍");
}
else
{
ModPE.setGameSpeed(20);
clientMessage(language.prefix+"无效数字,切换为普通速度");
}
dialog.dismiss();
}}});

var dialog = createDialog(layout, {title: "改变游戏速度"});
dialog.show();
}
catch(error)
{
print(error);
}
}
// ================================
function openBuildMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "建筑菜单", size: 21, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));
//几何体
createButton(layout, {text: "几何体", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
geometryMenu();
}}});
//模板
createButton(layout, {text: "模板", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
templetMenu();
}}});
//改重生点
createButton(layout, {text: "设重生点", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
setSpawn();
}}});
//脚下生方块
createButton(layout, {text: "脚下生基岩", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
setBlock();
}}});

createPopupWindow(createScrollView(ctx, layout), {width: getWidth() * 0.2, height: getHeight(), background: android.graphics.Color.argb(31, 0, 0, 0), focusable: true,
 gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: getWidth() * 0.25, y: 0});
}
catch(error)
{
print(error); 
}
}

const SELECT = {
tool: 290,
none: 0,
first: 1,
second: 2
};
const GEOMETRY_TYPE = {
solidSquare: 1

};

function geometryMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "几何体", size: 19, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));
//两点填充
var button = createButton(layout, {text: "两点填充", size: 17}, {click: new android.view.View.OnClickListener(){onClick: function(view){
selectPoint(SELECT.second, GEOMETRY_TYPE.solidSquare);
}}});
//圆柱

//圆锥

createPopupWindow(createScrollView(layout), {width: getWidth() * 0.15, height: getHeight(), background: android.graphics.Color.argb(31, 0, 0, 0), focusable: true,
 gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: getWidth() * 0.45, y: 0});
}
catch(error)
{
print(error);
}
}

function selectPoint(point, type)
{
if(build.point == SELECT.none)
{
if(Player.getCarriedItem() <= 255)
{
build.select = SELECT.none;
build.point = point;
build.type = type;
build.x = new Array();
build.y = new Array();
build.z = new Array();
build.id = Player.getCarriedItem();
build.data = Player.getCarriedItemData();
print("用木锄选择两点");
}
else
{
print("请将要填充的方块拿在手中");
}
}
else
{
build = {point: SELECT.none};
print("取消建造几何体");
}
}

function createGeometry()
{
build.point = SELECT.none;
switch(build.type)
{
default: print("错误,没有此几何体类型"); break;
case GEOMETRY_TYPE.solidSquare: createSquare(null/*未实现*/, build.x[0], build.y[0], build.z[0], build.x[1], build.y[1], build.z[1], build.id, build.data); break;
}
}

function createSquare(type, x1, y1, z1, x2, y2, z2, id, data)
{
var xx1 = Math.min(x1, x2);
var yy1 = Math.min(y1, y2);
var zz1 = Math.min(z1, z2);
var xx2 = Math.max(x1, x2);
var yy2 = Math.max(y1, y2);
var zz2 = Math.max(z1, z2);
for(var xi = 0; xx1 + xi <= xx2; xi++)
{
for(var yi = 0; yy1 + yi <= yy2; yi++)
{
for(var zi = 0; zz1 + zi <= zz2; zi++)
{
var x = xx1 + xi, y = yy1 + yi, z = zz1 + zi;
if(Level.getTile(x, y, z) != id && Level.getData(x, y, z) != data)
Level.setTile(x, y, z, id, data);
}
}
}
print("实心长方体生成完毕");
}

function templetMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "模板", size: 19, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));
// 生成空岛
createButton(layout, {text: "生成空岛", size: 17}, {click: new android.view.View.OnClickListener(){onClick: function(view){
var x = parseInt(Player.getX());
var y = parseInt(Player.getY() + 1);
var z = parseInt(Player.getZ());
createIsland(x, y, z);
}}});

createPopupWindow(createScrollView(ctx), {width: getWidth() * 0.15, height: getHeight(), background: android.graphics.Color.argb(31, 0, 0, 0), focusable: true,
 gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: getWidth() * 0.45, y: 0});
}
catch(error)
{
print(error);
}
}

function createIsland(jx, jy, jz)
{
var code,a=0;
try
{
code = [-3,3,0,3,0,-3,4,-1,2,0,-3,4,0,2,0,-3,4,1,2,0,-2,2,0,3,0,-2,3,-1,3,0,-2,3,0,3,0,-2,3,1,3,0,-2,4,-2,2,0,-2,4,-1,2,0,-2,4,0,2,0,-2,4,1,2,0,-2,4,2,2,0,-2,8,-1,18,12,-2,8,0,18,8,-2,8,1,18,12,-2,9,0,18,8,-1,1,0,3,0,-1,2,-1,3,0,-1,2,0,3,0,-1,2,1,3,0,-1,3,-2,3,0,-1,3,-1,3,0,-1,3,0,3,0,-1,3,1,3,0,-1,3,2,3,0,-1,4,-3,2,0,-1,4,-2,2,0,-1,4,-1,2,0,-1,4,0,2,0,-1,4,1,2,0,-1,4,2,2,0,-1,4,3,2,0,-1,8,-2,18,12,-1,8,-1,18,12,-1,8,0,18,12,-1,8,1,18,12,-1,8,2,18,12,-1,9,-1,18,12,-1,9,0,18,8,-1,9,1,18,12,-1,10,0,18,8,0,0,0,7,0,0,1,-1,3,0,0,1,1,3,0,0,2,-2,3,0,0,2,-1,3,0,0,2,1,3,0,0,2,2,3,0,0,3,-3,3,0,0,3,-2,3,0,0,3,-1,3,0,0,3,1,3,0,0,3,2,3,0,0,3,3,3,0,0,4,-3,2,0,0,4,-2,2,0,0,4,-1,2,0,0,4,0,3,0,0,4,1,3,0,0,4,2,2,0,0,4,3,2,0,0,5,-1,54,[2,79,0,2,325,10,1,13,0,1,50,0,1,360,0,1,361,0,1,458,0,1,338,0,1,81,0,1,39,0,1,40,0,1,352,0,1,298,0,1,299,0,1,300,0,1,301,0,1,347,0,[1,"要有耐心"],345,0,[1,"不要迷失"]],0,5,0,17,0,0,5,1,91,0,0,6,0,17,0,0,7,0,17,0,0,8,-2,18,8,0,8,-1,18,8,0,8,0,17,0,0,8,1,18,12,0,8,2,18,12,0,9,-2,18,8,0,9,-1,18,8,0,9,0,17,0,0,9,1,18,12,0,9,2,18,8,0,10,-1,18,8,0,10,0,18,8,0,10,1,18,8,1,1,0,3,0,1,2,-1,3,0,1,2,0,3,0,1,2,1,3,0,1,3,-2,3,0,1,3,-1,3,0,1,3,0,3,0,1,3,1,3,0,1,3,2,3,0,1,4,-3,2,0,1,4,-2,2,0,1,4,-1,2,0,1,4,0,2,0,1,4,1,2,0,1,4,2,2,0,1,4,3,2,0,1,8,-2,18,12,1,8,-1,18,12,1,8,0,18,12,1,8,1,18,12,1,8,2,18,12,1,9,-1,18,8,1,9,0,18,8,1,9,1,18,12,1,10,0,18,8,2,2,0,3,0,2,3,-1,3,0,2,3,0,3,0,2,3,1,3,0,2,4,-2,2,0,2,4,-1,2,0,2,4,0,2,0,2,4,1,2,0,2,4,2,2,0,2,8,-1,18,12,2,8,0,18,8,2,8,1,18,12,2,9,0,18,8,3,3,0,3,0,3,4,-1,2,0,3,4,0,2,0,3,4,1,2,0,-3,5,-1,31,1,-3,5,1,31,2,-2,5,-2,31,1,-2,5,-1,31,2,-2,5,0,31,1,-2,5,1,37,0,-2,5,2,31,2,-1,5,-2,31,1,-1,5,-1,31,1,-1,5,1,31,1,-1,5,2,31,1,-1,5,3,31,1,0,1,0,12,0,0,2,0,12,0,0,3,0,12,0,0,5,-3,63,[0,language.sign_prefix,Player.getName(Player.getEntity()),language.sign_warn,language.sign_author],0,5,-2,31,2,0,5,2,31,1,0,5,3,31,1,1,5,-2,38,0,1,5,-1,31,1,1,5,0,31,2,1,5,1,31,1,1,5,2,31,1,1,5,3,31,1,2,5,-1,31,1,2,5,0,31,2,2,5,1,31,1,3,5,0,31,1];
}
catch(error)
{
print("不是标准的建筑代码！");
return -1;
}
for(i=0;i<code.length;i=i+5)
{
if(code[i+3]==63 || code[i+3]==68)
{
Level.setTile(parseInt(code[i+0])+jx,parseInt(code[i+1])+jy,parseInt(code[i+2])+jz,code[i+3],code[i+4][0]);
for(ii=1;ii<code[i+4].length;ii++)
{
Level.setSignText(parseInt(code[i+0])+jx,parseInt(code[i+1])+jy,parseInt(code[i+2])+jz,ii-1,code[i+4][ii]);
}
}
else if(code[i+3]==54)
{
Level.setTile(parseInt(code[i+0])+jx,parseInt(code[i+1])+jy,parseInt(code[i+2])+jz,code[i+3],code[i+4][0]);
var arr=code[i+4];
//arr.shift();
var islot = 0;
for(ii=1;ii<arr.length;ii=ii+3)
{
if(arr[ii]==347 || arr[ii]==345)
{
Level.setChestSlot(parseInt(code[i+0])+jx,parseInt(code[i+1])+jy,parseInt(code[i+2])+jz,islot,arr[ii],arr[ii+1],arr[ii+2][0]);
var arr2=arr[ii+2];
Level.setChestSlotCustomName(parseInt(code[i+0])+jx,parseInt(code[i+1])+jy,parseInt(code[i+2])+jz,islot,arr2[1]);
islot++;
}
else
{
Level.setChestSlot(parseInt(code[i+0])+jx,parseInt(code[i+1])+jy,parseInt(code[i+2])+jz,islot,arr[ii],arr[ii+1],arr[ii+2]);
islot++;
}
}
}
else
{
Level.setTile(parseInt(code[i+0])+jx,parseInt(code[i+1])+jy,parseInt(code[i+2])+jz,code[i+3],code[i+4]);
}
a++;
}
return a;
}

function setSpawn()
{
Level.setSpawn(Player.getX(), Player.getY(), Player.getZ());
clientMessage(language.prefix+"已设置玩家位置为重生点");
}

function setBlock()
{
var x = parseInt(Player.getX());
var y = parseInt(Player.getY() - 2);
var z = parseInt(Player.getZ());
Level.setTile(x, y, z, 7);
clientMessage(language.prefix+"在 x:"+x+",y:"+y+",z:"+z+" 处生成基岩");
}
// ================================
function openColoreggMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "彩蛋", size: 21, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));
//控制生物
var button = createButton(layout, {text: "控制生物", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){

}}});
//炫酷粒子
createButton(layout, {text: "炫酷粒子", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
if(!particle.open) setParticle();
else
{
clientMessage(language.prefix+"粒子效果已清除");
particle.open = false;
}
}}});
//重力感应
createButton(layout, {text: "重力感应", size: 19}, {click:new android.view.View.OnClickListener(){onClick: function(view){
if(!sensor.open) openSensor();
else
{
var service = ctx.getSystemService(ctx.SENSOR_SERVICE);
service.unregisterListener(sensor.listener);
sensor.listener = null;
sensor.open = false;
}
}}});
//核弹
createButton(layout, {text: "核弹", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
superTNT();
}}});

createPopupWindow(createScrollView(ctx, layout), {width: getWidth() * 0.2, height: getHeight(), background: android.graphics.Color.argb(63, 0, 0, 0), focusable: true,
 gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: getWidth() * 0.25, y: 0});
}
catch(error)
{
print(error);
}
}

function controlEntity()
{

}

function setParticle()
{
var number = android.text.InputType.TYPE_CLASS_NUMBER;
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

createText(layout, {text: "粒子类型: "});
var spinner = createSpinner(layout, String("未选择,村民生气,泡泡粒子,云烟粒子,暴击粒子,滴落岩浆,滴落水滴,附魔文字,掉落沙,火焰粒子,村民开心,爱心粒子,巨大爆炸,巨大爆炸种子？,墨水粒子,物品损坏,大型爆炸,岩浆粒子,怪物燃烧,音符粒子,传送门粒子,跳动雨滴,红石粒子,史莱姆粒子,烟雾粒子,烟雾粒子2,雪球粒子,药水粒子,药水粒子2,药水粒子3,喷溅粒子,悬浮沙粒子,地形粒子,海浪粒子").split(","));
var editSize = createEditText(layout, {text: "大小设置: ", hint: "输入尺寸", inputType: number});
editSize.setText(String(100));
var editSpeed = createEditText(layout, {text: "速度设置: ", hint: "输入速度", inputType: number});
editSpeed.setText(String(0));
createText(layout, {text: "调完速度后果自负→_→"});
createButton(layout, {text: "开启五毛钱特效之旅"}, {click: new android.view.View.OnClickListener(){onClick: function(){
if(spinner.getSelectedItemId() != 0)
{
switch(spinner.getSelectedItemId())
{
case 1:particle.id = ParticleType.angryVillager;break;
case 2:particle.id = ParticleType.bubble;break;
case 3:particle.id = ParticleType.cloud;break;
case 4:particle.id = ParticleType.crit;break;
case 5:particle.id = ParticleType.dripLava;break;
case 6:particle.id = ParticleType.dripWater;break;
case 7:particle.id = ParticleType.enchantmenttable;break;
case 8:particle.id = ParticleType.fallingDust;break;
case 9:particle.id = ParticleType.flame;break;
case 10:particle.id = ParticleType.happyVillager;break;
case 11:particle.id = ParticleType.heart;break;
case 12:particle.id = ParticleType.hugeexplosion;break;
case 13:particle.id = ParticleType.hugeexplosionSeed;break;
case 14:particle.id = ParticleType.ink;break;
case 15:particle.id = ParticleType.itemBreak;break;
case 16:particle.id = ParticleType.largeexplode;break;
case 17:particle.id = ParticleType.lava;break;
case 18:particle.id = ParticleType.mobFlame;break;
case 19:particle.id = ParticleType.note;break;
case 20:particle.id = ParticleType.portal;break;
case 21:particle.id = ParticleType.rainSplash;break;
case 22:particle.id = ParticleType.redstone;break;
case 23:particle.id = ParticleType.slime;break;
case 24:particle.id = ParticleType.smoke;break;
case 25:particle.id = ParticleType.smoke2;break;
case 26:particle.id = ParticleType.snowballpoof;break;
case 27:particle.id = ParticleType.spell;break;
case 28:particle.id = ParticleType.spell2;break;
case 29:particle.id = ParticleType.spell3;break;
case 30:particle.id = ParticleType.splash;break;
case 31:particle.id = ParticleType.suspendedTown;break;
case 32:particle.id = ParticleType.terrain;break;
case 33:particle.id = ParticleType.waterWake;break;
}
particle.size = parseInt(editSize.getText());
particle.speed = parseInt(editSpeed.getText());
particle.open = true;
clientMessage(language.prefix+"粒子效果已变更");
}
else
{
particle.open = false;
clientMessage(language.prefix+"粒子效果已清除");
}
dialog.dismiss();
}}});

var dialog = createDialog(layout, {title: "选择炫酷粒子"});
dialog.show();
}
catch(error)
{
print(error);
}
}

function openSensor()
{
try
{
var service = ctx.getSystemService(ctx.SENSOR_SERVICE);
var defSensor = service.getDefaultSensor(android.hardware.Sensor.TYPE_GYROSCOPE);
sensor.listener = new android.hardware.SensorEventListener({onSensorChanged: function(se){
sensor.x = se.values[android.hardware.SensorManager.DATA_X];
sensor.y = se.values[android.hardware.SensorManager.DATA_Y];
}});
service.registerListener(sensor.listener, defSensor, android.hardware.SensorManager.SENSOR_DELAY_GAME);
sensor.open = true;
//Entity.setRot(Player.getEntity(), sensor.x * 180 / Math.PI / 10, sensor.y * 180 / Math.PI / 10);
}
catch(error)
{
print(error)
}
}

function spawnSuperTNT()
{
var number = android.text.InputType.TYPE_CLASS_NUMBER;
try
{
var layout=new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var editSize = createEditText(layout, {text: "威力: ", hint: "输入威力", inputType: number});
editSize.setText(String(6));
createText(layout, {text: "威力建议在18以内，小心卡死", size: 22, color: android.graphics.Color.WHITE});
createButton(layout, {text: "Bomb!"}, {click: new android.view.View.OnClickListener(){onClick: function(){
for(var i = 2;i <= power.getText();i = i + 3)
{
Level.spawnMob(Player.getX(),Player.getY()+3,Player.getZ(),65);

Level.spawnMob(Player.getX(),Player.getY()+3,Player.getZ()+i,65);
Level.spawnMob(Player.getX()+i,Player.getY()+3,Player.getZ()+2*i,65);
Level.spawnMob(Player.getX()+i,Player.getY()+3,Player.getZ()+i,65);
Level.spawnMob(Player.getX()+i,Player.getY()+3,Player.getZ(),65);
Level.spawnMob(Player.getX()+2*i,Player.getY()+3,Player.getZ()+i,65);

Level.spawnMob(Player.getX(),Player.getY()+3,Player.getZ()-i,65);
Level.spawnMob(Player.getX()+i,Player.getY()+3,Player.getZ()-2*i,65);
Level.spawnMob(Player.getX()+i,Player.getY()+3,Player.getZ()-i,65);
Level.spawnMob(Player.getX()+i,Player.getY()+3,Player.getZ(),65);
Level.spawnMob(Player.getX()+2*i,Player.getY()+3,Player.getZ()-i,65);

Level.spawnMob(Player.getX(),Player.getY()+3,Player.getZ()-i,65);
Level.spawnMob(Player.getX()-i,Player.getY()+3,Player.getZ()-2*i,65);
Level.spawnMob(Player.getX()-i,Player.getY()+3,Player.getZ()-i,65);
Level.spawnMob(Player.getX()-i,Player.getY()+3,Player.getZ(),65);
Level.spawnMob(Player.getX()-2*i,Player.getY()+3,Player.getZ()-i,65);

Level.spawnMob(Player.getX(),Player.getY()+3,Player.getZ()+i,65);
Level.spawnMob(Player.getX()-i,Player.getY()+3,Player.getZ()+2*i,65);
Level.spawnMob(Player.getX()-i,Player.getY()+3,Player.getZ()+i,65);
Level.spawnMob(Player.getX()-i,Player.getY()+3,Player.getZ(),65);
Level.spawnMob(Player.getX()-2*i,Player.getY()+3,Player.getZ()+i,65);
}
dialog.dismiss();
}}});

var dialog = createDialog(layout, {tilte: "核弹~啦啦啦"});
dialog.show();
}
catch(error)
{
print(error);
}
}
// ================================
function openSettingMenu()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);

var text = createText(layout, {text: "设置菜单", size: 21, color: android.graphics.Color.WHITE});
text.setLayoutParams(createLayoutParam(layout, dip2px(ctx, 5), 0, 0, 0));

createButton(layout, {text: "更改语言", size: 19}, {click: new android.view.View.OnClickListener(){onClick: function(view){
selectLanguage();
}}});

createPopupWindow(createScrollView(layout), {width: getWidth() * 0.2, height: getHeight(), background: android.graphics.Color.argb(63, 0, 0, 0), focusable: true,
 gravity: android.view.Gravity.RIGHT | android.view.Gravity.TOP, x: getWidth() * 0.25, y: 0});
}
catch(error)
{
print(error);
}
}

function selectLanguage()
{
try
{
var layout = new android.widget.LinearLayout(ctx);
layout.setOrientation(android.widget.LinearLayout.VERTICAL);
/*重新设计成带单选项的对话框
//自动
createButton(layout, {text: "Auto(自动)"}, {click: new android.view.View.OnClickListener(){onClick: function(){
options.configs.Default.Language = ModPE.getLanguage();
loadLanguage();
saveGlobalSettings();
dialog.dismiss();
}}});
//中文
var button = createButton(layout, "中文(中国)", null);
button.setOnClickListener(new android.view.View.OnClickListener(){onClick: function(){
options.configs.Default.Language = "zh_CN";
loadLanguage();
saveGlobalSettings();
print(language.setlang);
dialog.dismiss();
}});
layout.addView(button);
//英语
var button = createButton(layout, "English(US)", null);
button.setOnClickListener(new android.view.View.OnClickListener(){onClick: function(){
options.configs.Default.Language = "en_US";
loadLanguage();
saveGlobalSettings();
print(language.setlang);
dialog.dismiss();
}});

moreLanguage();
*/
var dialog = createDialog(layout, {title: "修改语言", cancelable: false, touchCancelable: false});
dialog.show();
}
catch(error)
{
print(error);
}
}

function moreLanguage()
{

}
// ================================
function about()
{
try
{
var authorList = new Array();
for(var i = 0; i < jsInfo.js_author.length; i++)
{
authorList.push(jsInfo.js_author[i] + ",QQ: " + jsInfo.js_author_QQ[i]);
}
var message = [
"空岛小帮手插件, 版本: " + jsInfo.js_version.toString(),
"作者名单: " + authorList.join(";        "),
"更新网址: " + jsInfo.js_webPage,
"Github: " + jsInfo.js_githubPage,
"曙光工艺工作室QQ群: " + jsInfo.js_QQGroup,
"欢迎您的加入",
"同时欢迎您提交bug或是建议",
"感谢您的使用!"
];

var dialog = createAlertDialog(null, {title: "关于", message: message.join("\n"), positive:"返回"}, {positive: new android.content.DialogInterface.OnClickListener(){onClick: function(dialog, w){
dialog.dismiss();
}}});
dialog.show();
}
catch(error)
{
print(error);
}
}
// ================================
/* 以下均为 曙光API 版本 V0.1 作者:QingChenW
您可以随意在您的作品中使用,甚至是修改,但需注明作者,如有原作者也请注明
 */
// 游戏工具函数
/** registerItem 用于注册一个物品
 * 参数: int(请见ITEM_TYPE) type 物品种类
 *       int id 物品的序号ID
 *       int data 物品的最大数据值(损害值)
 *       int count 物品的最大堆叠
 *       string name 物品名称
 *       string texture 物品纹理名称
 *       array recipe 物品合成配方(设置为null为没有配方，格式为[数量, par4Scriptable, par5Scriptable]
 *       int category 物品栏类别(设置为null为不添加到创造物品栏中)，请参考启动器函数表
 *       未知 other 其他数据
 * 作者: QingChenW, 使用时请注明作者
 * 另请参考: ITEM_TYPE
 */
function registerItem(type, id, data, count, name, texture, recipe, category, other)
{
switch(type)
{
// 注册普通物品
case ITEM_TYPE.item:
ModPE.setItem(id, texture, 0, name, count);
Item.setMaxDamage(id, data);
break;
// 注册食物
case ITEM_TYPE.food:
ModPE.setFoodItem(id, texture, 0, add, name, other);
break;
// 注册工具
case ITEM_TYPE.tool:
ModPE.setItem(id, texture, 0, name, count);
Item.setMaxDamage(id, data);
Item.setHandEquipped(id, true);
break;
// 注册盔甲
case ITEM_TYPE.armor:
//Item.defineArmor(par1int, par2String, par3int, par4String, par5String, par6int, par7int, par8int);
// 注册投掷物
case ITEM_TYPE.throwable:
//Item.defineThrowable(par1int, par2String, par3int, par4String, par5int);
throw "未制作，敬请期待";
// 未知类型
default:
throw "unknownItemType:未知的物品种类，无法注册物品";
return;
}
// 注册合成表
if(recipe != null)
{
Item.addShapedRecipe(id, recipe[0], data, recipe[1], recipe[2]);
}
// 注册物品栏
if(category != null)
{
Player.addItemCreativeInv(id, 1, 0);
Item.setCategory(id, category);
}
}

/** registerBlock 用于注册一个方块
 * 参数: int(请见BLOCK_TYPE) type 方块种类
 *       int id 方块的序号ID
 *       string name 方块名称
 *       array textures 方块纹理，请参考启动器函数表
 *       renderType renderType 方块渲染种类，请参考启动器函数表
 *       int destroy 方块破坏时间
 *       int expRes 方块爆炸抗性
 *       int light 方块光照
 *       array shape 方块形状，请参考启动器函数表
 *       array recipe 方块合成配方(设置为null为没有配方，格式为[数量, par4Scriptable, par5Scriptable]
 *       int category 物品栏类别(设置为null为不添加到创造物品栏中)，请参考启动器函数表
 * 作者: QingChenW, 使用时请注明作者
 * 另请参考: BLOCK_TYPE
 */
function registerBlock(type, id, name, textures, renderType, destroy, expRes, light, shape, recipe, category)
{
switch(type)
{
case BLOCK_TYPE.normal:
Block.defineBlock(id, name, textures, 1, false, renderType);
break;
case BLOCK_TYPE.glass:
Block.defineBlock(id, name, textures, 0, true, renderType);
break;
case BLOCK_TYPE.water:
//Block.defineLiquidBlock(id, name, par3Object, par4Object);
return;
break;
}
Block.setRenderLayer(id, type);
Block.setDestroyTime(id, destroy);
Block.setExplosionResistance(id, expRes);
Block.setLightLevel(id, light);
if(shape != null)
{
Block.setShape(id, shape[0], shape[1], shape[2], shape[3], shape[4], shape[5], shape[6]);
}
// 注册合成表
if(recipe != null)
{
Item.addShapedRecipe(id, recipe[0], 0, recipe[1], recipe[2]);
}
// 注册物品栏
if(category != null)
{
Player.addItemCreativeInv(id, 1, 0);
Item.setCategory(id, category);
}
}

function fastDestroyBlocks(x, y, z, id)
{
if(Level.getTile(x , y, z) == id) Level.destroyBlock(x, y, z, true);
if(Level.getTile(x + 1, y, z) == id) fastDestroyBlocks(x + 1, y, z, id);
if(Level.getTile(x + 1, y, z + 1) == id) fastDestroyBlocks(x + 1, y, z + 1, id);
if(Level.getTile(x - 1, y, z) == id) fastDestroyBlocks(x - 1, y, z, id);
if(Level.getTile(x - 1, y, z - 1) == id) fastDestroyBlocks(x - 1, y, z - 1, id);
}

/** getValue 反序列化一个值，并且如果该值不存在则返回默认值
 * 参数: 任意类型 variable 变量
 *      任意类型 defaultValue 默认值
 * 作者: QingChenW
 */
function getValue(variable, defaultValue)
{
var value = variable != undefined ? variable : defaultValue;
switch(typeof defaultValue)
{
case "string": return String(value); break;
case "number": return Number(value); break;
case "boolean": return Boolean(Number(value)); break;
case "array": return value.split("; "); break;
}
return value;
}

/** setValue 序列化一个值，并且如果该值不存在则序列化默认值
 * 参数: 任意类型 variable 变量
 *      任意类型 defaultValue 默认值
 * 作者: QingChenW
 */
function setValue(variable, defaultValue)
{
var value = variable != undefined ? variable : defaultValue;
switch(typeof defaultValue)
{
case "string": return String(value); break;
case "number": return Number(value); break;
case "boolean": return Number(value); break;
case "array": return value.join("; "); break;
}
return value;
}

// 小工具函数
/** killDuoWan 如果非方块启动器则退出
 * 作者: QingChenW
 * 备注: 无聊之作，所以并没有使用
 */
function killDuoWan()
{
const $ = ctx.getPackageName();
if($ != "net.zhuoweizhang.mcpelauncher" && $ != "net.zhuoweizhang.mcpelauncher.pro")
{
toast("本js只能使用方块启动器加载！\n即将退出游戏！");
new java.lang.Thread(ctx).sleep(5000);
ctx.runOnUiThread(new java.lang.Runnable({run:function(){
ctx.finish();
}}));
}
}

/** toast 无前缀的print
 * 参数: string content 内容
 * 作者: 来自互联网，作者忘了。。。
 */
function toast(content)
{ 
ctx.runOnUiThread(new java.lang.Runnable({run: function(){ 
android.widget.Toast.makeText(ctx, content, 0).show();
}}));
}

/** getClipBoard 获取剪贴板
 * 返回值: 未知 content 剪贴板内容
 * 作者: 来自JSIDE，作者忘了。。。
 */
function getClipBoard()
{
var context;
ctx.runOnUiThread(new java.lang.Runnable({run: function(){
cm = ctx.getSystemService(ctx.CLIPBOARD_SERVICE).getText();
}}));
return content;
}

/** openUrl 打开网址
 * 参数: string url 网址
 * 作者: 来自互联网，作者忘了。。。
 */
function openUrl(url)
{
ctx.startActivity(new android.content.Intent(android.content.Intent.ACTION_VIEW,android.net.Uri.parse(url)));
}

/** notify 向通知栏中发送通知
 * 参数: string main 主题
 *       string title 标题
 *       string content 内容
 *       string url 打开的网址
 * 作者: 来自互联网，作者忘了。。。
 */
function notify(main, title, content, url)
{
var intent=new android.content.Intent(android.content.Intent.ACTION_VIEW,android.net.Uri.parse(url));
var pi=android.app.PendingIntent.getActivity(ctx,0,intent,0);
ctx.runOnUiThread(new java.lang.Runnable(){run: function(){
var nm=ctx.getSystemService(ctx.NOTIFICATION_SERVICE);
var notify=new android.app.Notification(android.R.drawable.btn_dialog,main,0);
notify.defaults=android.app.Notification.DEFAULT_SOUND;
notify.setLatestEventInfo(ctx,title,content,pi);
nm.notify(0,notify);
}});
}

/** decodePicture 用于将base64解码
 * 参数: string base64 一个base字符串
 * 返回值: Bitmap 解码后的位图
 * 作者: QingChenW
 */
function decodePicture(base64)
{
var byte = android.util.Base64.decode(base64,0);
var image = android.graphics.BitmapFactory.decodeByteArray(byte, 0, byte.length);
return image;
}

/** httpGet 用于从网站读取字符串
 * 参数: string url 一个网址
 * 返回值: string 读取后的字符串，如果失败则返回空串
 * 作者: 来自MxGoldo的minimap-mcpe
 */
function httpGet(url)
{
try
{
var content = new java.io.ByteArrayOutputStream();
android.net.http.AndroidHttpClient.newInstance("userAgent").execute(new org.apache.http.client.methods.HttpGet(url)).getEntity().writeTo(content);
content.close();
return String(content.toString());
}
catch(error)
{
return "";
}
}

/** httpPost 用于向网站发送数据
 * 参数: string url 一个网址
 * 返回值: string 读取后的字符串，如果失败则返回空串
 * 作者: SER初心
 * 备注: 等待重写
 */
function httpPost(uriAPI, padata)
{
var httpRequest = new org.apache.http.client.methods.HttpPost(uriAPI);
var params = [];
for(var i in padata)params.push(new org.apache.http.message.BasicNameValuePair(i, padata[i]));
try {
	httpRequest.setEntity(new org.apache.http.client.entity.UrlEncodedFormEntity(params, org.apache.http.protocol.HTTP.UTF_8));
	var httpResponse = new org.apache.http.impl.client.DefaultHttpClient().execute(httpRequest);
	if (httpResponse.getStatusLine().getStatusCode() == 200) {
		var strResult = org.apache.http.util.EntityUtils.toString(httpResponse.getEntity());
		return strResult;
	} else {
		return "Error Response" + httpResponse.getStatusLine().toString();
	}
} catch (e) {
	return "Error " + e;
}
}

/** save 保存文件
 * 参数: string path 文件路径
 *       string filename 文件名称
 *       boolean write 是否写入文件
 *       string content 文件内容
 * 作者: 来自MxGoldo的minimap-mcpe,QingChenW修改
 */
function save(path, filename, write, content)
{
try
{
java.io.File(path).mkdirs();
var newFile = new java.io.File(path, filename);
newFile.createNewFile();
var outWrite = new java.io.OutputStreamWriter(new java.io.FileOutputStream(newFile, write));
outWrite.append(content);
outWrite.close();
return true;
}
catch(error)
{
print("save, " + error + " (" + error.fileName + " #" + error.lineNumber + ")");
return false;
}
}

/** load 读取文件
 * 参数: string path 文件路径
 *       string filename 文件名称
 * 返回值: string 文件内容
 * 作者: 来自MxGoldo的minimap-mcpe
 * 备注: 我将最后的返回值强制转换成了string
 */
function load(path, filename)
{
var content = "";
if(java.io.File(path + filename).exists())
{
var file = new java.io.File(path + filename),
fos = new java.io.FileInputStream(file),
str = new java.lang.StringBuilder(),
ch;
while((ch = fos.read()) != -1)
{
str.append(java.lang.Character(ch));
}
content = String(str.toString());
fos.close();
}
return content;
}

// 各种类
// (完全没有卵用的吐槽:额其实js是面向对象的,刚学的时候我完全不知道,好吧我刚学的时候连对象是啥都不知道...)


// GUI工具函数
/* 备注: 其实这些都是曙光API未完成的东东啦
3	AutoCompleteTextView
AutoCompleteTextView是一个视图，它类似于EditText，不同之处是在用户键入时，它会显示自动完成建议的列表。
10	ProgressBar
进度条视图（ProgressBar）提供一些日常任务，当在后台执行任务时，给出视觉反馈。

Color.BLACK           黑色
Color.BLUE            蓝色
Color.CYAN            青绿色
Color.DKGRAY          灰黑色
Color.GRAY            灰色
Color.GREEN           绿色
Color.LTGRAY          浅灰色
Color.MAGENTA         红紫色
Color.RED             红色
Color.TRANSPARENT     透明
Color.WHITE           白色
Color.YELLOW          黄色
 */
 
/** dip2px 将设备独立像素转换为像素
 * 参数: ctx 就是ctx
 *       dips 设备独立像素
 * 返回值: dp 像素
 */
function dip2px(ctx, dips)
{
return Math.ceil(dips*ctx.getResources().getDisplayMetrics().density);
}

/** createScrollMenu 生成一个带滚动条的菜单布局
 * 参数: layout 布局
 * 返回值: scrollView 带滚动条的视图
 */
function createScrollView(layout)
{
var mlayout = new android.widget.RelativeLayout(ctx);
var svParams = new android.widget.RelativeLayout.LayoutParams(android.widget.RelativeLayout.LayoutParams.FILL_PARENT, android.widget.RelativeLayout.LayoutParams.FILL_PARENT);
var scrollView = new android.widget.ScrollView(ctx);
var pad = dip2px(ctx, 2);
scrollView.setPadding(pad, pad, pad, pad);
scrollView.setLayoutParams(svParams);
scrollView.addView(layout);
mlayout.addView(scrollView);
return mlayout;
}

/** createPopupWindow 生成一个窗口
 * 参数: layout 布局
 *       width 窗口宽度
 *       height 窗口高度
 *       color 背景颜色
 *       focusable 触摸其他地方是否会关闭窗口
 *       touchable 是否可以触摸
 * 返回值: PopupWindow 生成的窗口
 * 作者: QingChenW
 */
function createPopupWindow(layout, property, listener)
{
var window = new android.widget.PopupWindow(layout, property.width, property.height);
if(property.background != undefined) window.setBackgroundDrawable(property.background);
if(property.focusable != undefined) window.setFocusable(property.focusable);
if(property.touchable != undefined) window.setTouchable(property.touchable);
window.showAtLocation(ctx.getWindow().getDecorView(), property.gravity, property.x, property.y);
return window;
}

/** createDialog 生成一个对话框
 * 参数: layout 布局
 *       title 对话框标题
 *       cancelable 触摸其他地方以及返回键是否会关闭对话框
 * 返回值: Dialog 生成的对话框
 * 作者: QingChenW
 */
function createDialog(layout, property)
{
var dialog = new android.app.Dialog(ctx);
dialog.setContentView(layout);
dialog.setTitle(property.title);
if(property.cancelable != undefined) dialog.setCancelable(property.cancelable);
if(property.touchCancelable != undefined) dialog.setCanceledOnTouchOutside(property.touchCancelable);
return dialog;
}

/** createAlertDialog 生成一个警告对话框
 * 参数: layout 布局
 *       property 属性  {

                        
                        }
 *       listener 事件监听器{

                        }
 * 返回值: Dialog 生成的对话框
 * 作者: QingChenW
 */
function createAlertDialog(layout, property, listener)
{
var dialog = new android.app.AlertDialog.Builder(ctx);
dialog.setTitle(property.title);
dialog.setMessage(property.message);
if(property.cancelable != undefined) dialog.setCancelable(property.cancelable);
if(property.touchCancelable != undefined) dialog.setCanceledOnTouchOutside(property.touchCancelable);
if(property.positive != undefined) dialog.setPositiveButton(property.positive, listener.positive);
if(property.natural != undefined) dialog.setNaturalButton(property.natural, listener.natural);
if(property.negative != undefined) dialog.setNegativeButton(property.negative, listener.negative);
return dialog;
}

/** createProgressDialog 生成一个进度对话框
 *       property 属性  {

                        
                        }
 * 返回值: Dialog 生成的对话框
 * 作者: QingChenW
 */
function createProgressDialog(layout, property)
{
var dialog = new android.app.ProgressDialog(ctx);
dialog.setTitle(property.title);
dialog.setMessage(property.message);
dialog.setMax(property.max);
if(property.style == undefined) property.style = android.app.ProgressDialog.STYLE_HORIZONTAL;
dialog.setProgressStyle(property.style);
if(property.cancelable != undefined) dialog.setCancelable(property.cancelable);
if(property.touchCancelable != undefined) dialog.setCanceledOnTouchOutside(property.touchCancelable);
return dialog;
}

/** createText 生成文字视图
 * 参数: layout 布局
 *       property 属性  {

                        
                        }
 * 返回值: TextView 文字视图
 * 作者: QingChenW
 */
function createText(layout, property)
{
var textView = new android.widget.TextView(ctx);
textView.setText(property.text);
if(property.size != undefined) textView.setTextSize(property.size);
if(property.gravity != undefined) textView.setGravity(property.gravity);
if(property.color != undefined) textView.setTextColor(property.color);
layout.addView(textView);
return textView;
}

/** createImage 生成图片视图
 * 参数: layout 布局
 *       property 属性  {

                        
                        }
 * 返回值: ImageView 生成的图片布局
 * 作者: QingChenW
 */
function createImage(layout, property)
{
var imageView = new android.widget.ImageView(ctx);
imageView.setImageBitmap(property.image);
if(property.scaleType == undefined) property.scaleType = android.widget.ImageView.ScaleType.CENTER_CROP;
imageView.setScaleType(property.scaleType);
layout.addView(imageView);
return imageView;
}

/** createEditText 生成文本编辑框
 * 参数: layout 布局
 *       property 属性  {

                        
                        }
 *       listener 事件监听器{

                        }
 * 返回值: TextView 文字视图
 * 作者: QingChenW
 */
function createEditText(layout, property)
{
var editText = new android.widget.EditText(ctx);
editText.setText(text);
if(property.hint != undefined) editText.setHint(hint);
if(property.inputType != undefined) editText.setInputType(inputType);
if(property.size != undefined) editText.setTextSize(size);
if(property.color != undefined) editText.setTextColor(color);
layout.addView(editText);
return editText;
}

/** createButton 生成一个按钮
 * 参数: layout 布局
 *       property 属性  {
                        text: 按钮文本(必须)
                        size: 按钮文本尺寸(可选)
                        color: 按钮文本颜色(可选)
                        background: 按钮背景(可选)
                        
                        }
 *       listener 事件监听器{
                        click: 点击事件监听器
                        }
 * 返回值: Button 生成的按钮
 * 作者: QingChenW
 */
function createButton(layout, property, listener)
{
var button = new android.widget.Button(ctx);
button.setText(property.text);
if(property.size != undefined) button.setTextSize(property.size);
if(property.color != undefined) button.setTextColor(property.color);
if(property.background != undefined) setBackground(property.background);
if(listener.click != undefined) button.setOnClickListener(listener.click);
layout.addView(button);
return button;
}

/** createToggleButton 生成开关按钮
 * 参数: layout 布局
 *       property 属性  {

                        
                        }
 *       listener 事件监听器{

                        }
 * 返回值: ToggleButton 生成的开关按钮
 * 作者: QingChenW
 */
function createToggleButton(layout, property, listener)
{
var button = new android.widget.ToggleButton(ctx);
button.setTextOn(property.textOn);
button.setTextOff(property.textOff);
button.setChecked(property.isChecked);
if(property.size != undefined) button.setTextSize(property.size);
if(property.color != undefined) button.setTextColor(property.color);
if(property.background != undefined) setBackground(property.background);
if(listener.click != undefined) button.setOnClickListener(listener.click);
layout.addView(button);
return button;
}

/** createImageButton 生成一个图片按钮
 * 参数: layout 布局
 *       property 属性  {

                        
                        }
 *       listener 事件监听器{

                        }
 * 返回值: ImageButton 生成的图片按钮
 * 作者: QingChenW
 */
function createImageButton(layout, property, listener)
{
var button = new android.widget.ImageButton(ctx);
button.setImageBitmap(property.image);
if(property.scaleType == undefined) property.scaleType = android.widget.ImageView.ScaleType.CENTER_CROP;
button.setScaleType(property.scaleType);
if(property.background != undefined) button.setBackgroundDrawable(property.background);
if(listener.click != undefined) button.setOnClickListener(listener.click);
layout.addView(button);
return button;
}

/** createRadioButton 生成单选按钮
 * 参数: layout 布局
 *       property 属性
 * 返回值: RadioButton 生成的单选按钮
 * 作者: QingChenW
 */
function createRadioButton(layout, property)
{
var button = new android.widget.CheckBox(ctx);
button.setText(property.text);
button.setChecked(property.isChecked);
if(property.size != undefined) button.setTextSize(property.size);
if(property.color != undefined) button.setTextColor(property.color);
layout.addView(button);
return button;
}

/** createRadioGroup 生成单选按钮组
 * 参数: property 属性
 *       listener 事件监听器
 * 返回值: RadioGroup 生成的单选按钮组
 * 作者: QingChenW
 * 备注: 从API里我查到其实radiogroup继承了LinearLayout,所以可以使用setOrientation();
 *       如果有必要的话还可以给radiobutton加params,不过要记住是RadioGroup.LayoutParams
 *       listener是new OnCheckedChangeListener(){function: onCheckedChanged(group, checkedId){}}
 */
function createRadioGroup(property, listener)
{
var group = new android.widget.CheckBox(ctx);
if(property.orientation != undefined) group.setOrientation(property.orientation);
if(listener.change) group.setOnCheckedChangeListener(listener.change);
return group;
}

 /** createCheckBox 生成单选框
 * 参数: layout 布局
 *       property 属性
 *       listener 事件监听器
 * 返回值: CheckBox 生成的单选框
 * 作者: QingChenW
 */
function createCheckBox(layout, property, listener)
{
var check = new android.widget.CheckBox(ctx);
check.setText(property.text);
check.setChecked(property.isChecked);
if(property.size != undefined) check.setTextSize(property.size);
if(property.color != undefined) check.setTextColor(property.color);
if(listener.change != undefined) check.setOnCheckedChangeListener(listener.change);
layout.addView(check);
return check;
}

 /** createSeekBar 生成滑动条
 * 参数: layout 布局
 *       property 属性
 *       listener 事件监听器
 * 返回值: SeekBar 生成的滑动条
 * 作者: QingChenW
 */
function createSeekBar(layout, property, listener)
{
var seekBar = new android.widget.SeekBar(ctx);
seekBar.setMax(property.max);
if(property.progress != undefined) seekBar.setProgress(property.progress);
if(listener.change != undefined) seekBar.setOnSeekBarChangeListener(listener.change);
layout.addView(seekBar);
return seekBar;
}

/** createSpinner 生成下拉菜单
 * 参数: layout 布局
 *       property 属性
 *       listener 事件监听器
 * 返回值: Spinner 生成的下拉菜单
 * 作者: QingChenW
 * 备注: listener是这个select: new android.widget.AdapterView.OnItemSelectedListener(){onItemSelected: function(view){//...}}
 */
function createSpinner(layout, property, listener)
{
var spinner = new android.widget.Spinner(ctx);
if(property.style == undefined) property.style = android.R.layout.select_dialog_multichoice;
var adapter = new android.widget.ArrayAdapter(ctx, property.style, property.adapterArray);
spinner.setAdapter(adapter);
if(listener.select != undefined) spinner.setOnItemSelectedListener(listener.select);
layout.addView(spinner);
return spinner;
}

 /** createLayoutParam 根据布局生成一个param
 * 参数: layout 布局
 *       left 左间距
 *       top 上间距
 *       right 右间距
 *       bottom 下间距
 * 返回值: LayoutParams 生成的param
 * 作者: QingChenW
 */
function createLayoutParam(layout, left, top, right, bottom)
{
if(layout instanceof android.widget.LinearLayout)
{
var param = new android.widget.LinearLayout.LayoutParams(android.widget.RelativeLayout.LayoutParams.WRAP_CONTENT, android.widget.RelativeLayout.LayoutParams.WRAP_CONTENT);
param.setMargins(left, top, right, bottom);
return param;
}
return null;
}

/** getWidth 获取屏幕宽度
 * 返回值: 屏幕宽度
 * 作者: QingChenW
 */
function getWidth()
{
return ctx.getWindowManager().getDefaultDisplay().getWidth();
}

/** getHeight 获取屏幕高度
 * 返回值: 屏幕高度
 * 作者: QingChenW
 */
function getHeight()
{
return ctx.getWindowManager().getDefaultDisplay().getHeight();
}

// ================================
// 恭喜你,终于耐着性子看完了哦,累不累~
// 后话:
// 其实在第一版中我想加密来着,不过失败了
// 不过我也不想加密了,另外我还加了些注释
// 也是方便新手能从中学到一些东西
// 另外虽然插件比起第一版来说有些进步
// 不过由于我也是新手,难免有糟糕之处
// 还望大神指教
// By QingChenW